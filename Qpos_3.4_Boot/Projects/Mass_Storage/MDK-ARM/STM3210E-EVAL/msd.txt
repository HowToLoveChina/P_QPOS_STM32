; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\msd.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\msd.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\msd.crf ..\src\msd.c]
                          THUMB

                          AREA ||i.Buffercmp||, CODE, READONLY, ALIGN=1

                  Buffercmp PROC
;;;114    
;;;115    uint8_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  4603              MOV      r3,r0
;;;117      while (BufferLength--)
000004  e007              B        |L1.22|
                  |L1.6|
;;;118      {
;;;119        if (*pBuffer1 != *pBuffer2)
000006  7818              LDRB     r0,[r3,#0]
000008  780c              LDRB     r4,[r1,#0]
00000a  42a0              CMP      r0,r4
00000c  d001              BEQ      |L1.18|
;;;120        {
;;;121          return 0;
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;122        }
;;;123    
;;;124        pBuffer1++;
;;;125        pBuffer2++;
;;;126      }
;;;127    
;;;128      return 1;
;;;129    }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  1c5b              ADDS     r3,r3,#1              ;124
000014  1c49              ADDS     r1,r1,#1              ;125
                  |L1.22|
000016  0010              MOVS     r0,r2                 ;117
000018  f1a20401          SUB      r4,r2,#1              ;117
00001c  b2a2              UXTH     r2,r4                 ;117
00001e  d1f2              BNE      |L1.6|
000020  2001              MOVS     r0,#1                 ;128
000022  e7f5              B        |L1.16|
;;;130    /*******************************************************************************
                          ENDP


                          AREA ||i.MSD_GetDataResponse||, CODE, READONLY, ALIGN=1

                  MSD_GetDataResponse PROC
;;;334    *******************************************************************************/
;;;335    uint8_t MSD_GetDataResponse(void)
000000  b570              PUSH     {r4-r6,lr}
;;;336    {
;;;337      uint32_t i = 0;
000002  2500              MOVS     r5,#0
;;;338      uint8_t response, rvalue;
;;;339    
;;;340      while (i <= 64)
000004  e018              B        |L2.56|
                  |L2.6|
;;;341      {
;;;342        /* Read resonse */
;;;343        response = MSD_ReadByte();
000006  f7fffffe          BL       MSD_ReadByte
00000a  4604              MOV      r4,r0
;;;344        /* Mask unused bits */
;;;345        response &= 0x1F;
00000c  f004041f          AND      r4,r4,#0x1f
;;;346    
;;;347        switch (response)
000010  2c05              CMP      r4,#5
000012  d004              BEQ      |L2.30|
000014  2c0b              CMP      r4,#0xb
000016  d004              BEQ      |L2.34|
000018  2c0d              CMP      r4,#0xd
00001a  d106              BNE      |L2.42|
00001c  e003              B        |L2.38|
                  |L2.30|
;;;348        {
;;;349          case MSD_DATA_OK:
;;;350          {
;;;351            rvalue = MSD_DATA_OK;
00001e  2605              MOVS     r6,#5
;;;352            break;
000020  e005              B        |L2.46|
                  |L2.34|
;;;353          }
;;;354    
;;;355          case MSD_DATA_CRC_ERROR:
;;;356            return MSD_DATA_CRC_ERROR;
000022  200b              MOVS     r0,#0xb
                  |L2.36|
;;;357    
;;;358          case MSD_DATA_WRITE_ERROR:
;;;359            return MSD_DATA_WRITE_ERROR;
;;;360    
;;;361          default:
;;;362          {
;;;363            rvalue = MSD_DATA_OTHER_ERROR;
;;;364            break;
;;;365          }
;;;366        }
;;;367        /* Exit loop in case of data ok */
;;;368        if (rvalue == MSD_DATA_OK)
;;;369          break;
;;;370        /* Increment loop counter */
;;;371        i++;
;;;372      }
;;;373      /* Wait null data */
;;;374      while (MSD_ReadByte() == 0);
;;;375      /* Return response */
;;;376      return response;
;;;377    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  200d              MOVS     r0,#0xd               ;359
000028  e7fc              B        |L2.36|
                  |L2.42|
00002a  26ff              MOVS     r6,#0xff              ;363
00002c  bf00              NOP                            ;364
                  |L2.46|
00002e  bf00              NOP                            ;352
000030  2e05              CMP      r6,#5                 ;368
000032  d100              BNE      |L2.54|
000034  e002              B        |L2.60|
                  |L2.54|
000036  1c6d              ADDS     r5,r5,#1              ;371
                  |L2.56|
000038  2d40              CMP      r5,#0x40              ;340
00003a  d9e4              BLS      |L2.6|
                  |L2.60|
00003c  bf00              NOP                            ;369
00003e  bf00              NOP                            ;374
                  |L2.64|
000040  f7fffffe          BL       MSD_ReadByte
000044  2800              CMP      r0,#0                 ;374
000046  d0fb              BEQ      |L2.64|
000048  4620              MOV      r0,r4                 ;376
00004a  e7eb              B        |L2.36|
;;;378    
                          ENDP


                          AREA ||i.MSD_GetResponse||, CODE, READONLY, ALIGN=1

                  MSD_GetResponse PROC
;;;386    *******************************************************************************/
;;;387    uint8_t MSD_GetResponse(uint8_t Response)
000000  b570              PUSH     {r4-r6,lr}
;;;388    {
000002  4605              MOV      r5,r0
;;;389      uint32_t Count = 0xFFF;
000004  f64074ff          MOV      r4,#0xfff
;;;390    
;;;391      /* Check if response is got or a timeout is happen */
;;;392      while ((MSD_ReadByte() != Response) && Count)
000008  e000              B        |L3.12|
                  |L3.10|
;;;393      {
;;;394        Count--;
00000a  1e64              SUBS     r4,r4,#1
                  |L3.12|
00000c  f7fffffe          BL       MSD_ReadByte
000010  42a8              CMP      r0,r5                 ;392
000012  d001              BEQ      |L3.24|
000014  2c00              CMP      r4,#0                 ;392
000016  d1f8              BNE      |L3.10|
                  |L3.24|
;;;395      }
;;;396    
;;;397      if (Count == 0)
000018  b90c              CBNZ     r4,|L3.30|
;;;398      {
;;;399        /* After time out */
;;;400        return MSD_RESPONSE_FAILURE;
00001a  20ff              MOVS     r0,#0xff
                  |L3.28|
;;;401      }
;;;402      else
;;;403      {
;;;404        /* Right response got */
;;;405        return MSD_RESPONSE_NO_ERROR;
;;;406      }
;;;407    }
00001c  bd70              POP      {r4-r6,pc}
                  |L3.30|
00001e  2000              MOVS     r0,#0                 ;405
000020  e7fc              B        |L3.28|
;;;408    
                          ENDP


                          AREA ||i.MSD_GetStatus||, CODE, READONLY, ALIGN=2

                  MSD_GetStatus PROC
;;;415    *******************************************************************************/
;;;416    uint16_t MSD_GetStatus(void)
000000  b510              PUSH     {r4,lr}
;;;417    {
;;;418      uint16_t Status = 0;
000002  2400              MOVS     r4,#0
;;;419    
;;;420      /* MSD chip select low */
;;;421      MSD_CS_LOW();
000004  2110              MOVS     r1,#0x10
000006  4807              LDR      r0,|L4.36|
000008  f7fffffe          BL       GPIO_ResetBits
;;;422      /* Send CMD13 (MSD_SEND_STATUS) to get MSD status */
;;;423      MSD_WriteByte(CMD_RDSR);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       MSD_WriteByte
;;;424      Status = MSD_ReadByte();
000012  f7fffffe          BL       MSD_ReadByte
000016  4604              MOV      r4,r0
;;;425    
;;;426      /* MSD chip select high */
;;;427      MSD_CS_HIGH();
000018  2110              MOVS     r1,#0x10
00001a  4802              LDR      r0,|L4.36|
00001c  f7fffffe          BL       GPIO_SetBits
;;;428      /* Send dummy byte 0xFF */
;;;429    
;;;430      return Status;
000020  4620              MOV      r0,r4
;;;431    }
000022  bd10              POP      {r4,pc}
;;;432    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.MSD_GoIdleState||, CODE, READONLY, ALIGN=2

                  MSD_GoIdleState PROC
;;;440    *******************************************************************************/
;;;441    uint8_t MSD_GoIdleState(void)
000000  b510              PUSH     {r4,lr}
;;;442    {
;;;443      uint32_t FlashID = 0;
000002  2400              MOVS     r4,#0
;;;444      FlashID = SPI_FLASH_ReadID();
000004  f7fffffe          BL       SPI_FLASH_ReadID
000008  4604              MOV      r4,r0
;;;445      if (FlashID == FLASH_ID)
00000a  4803              LDR      r0,|L5.24|
00000c  4284              CMP      r4,r0
00000e  d101              BNE      |L5.20|
;;;446      {
;;;447       return MSD_RESPONSE_NO_ERROR;
000010  2000              MOVS     r0,#0
                  |L5.18|
;;;448      }
;;;449     
;;;450      return MSD_RESPONSE_FAILURE;
;;;451    }
000012  bd10              POP      {r4,pc}
                  |L5.20|
000014  20ff              MOVS     r0,#0xff              ;450
000016  e7fc              B        |L5.18|
;;;452    
                          ENDP

                  |L5.24|
                          DCD      0xef401700

                          AREA ||i.MSD_ReadBlock||, CODE, READONLY, ALIGN=2

                  MSD_ReadBlock PROC
;;;167    *******************************************************************************/
;;;168    uint8_t MSD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;169    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;170      uint32_t i = 0;
00000a  2700              MOVS     r7,#0
;;;171      uint8_t rvalue = MSD_RESPONSE_FAILURE;
00000c  f04f08ff          MOV      r8,#0xff
;;;172    
;;;173      /* MSD chip select low */
;;;174      MSD_CS_LOW();
000010  2110              MOVS     r1,#0x10
000012  4811              LDR      r0,|L6.88|
000014  f7fffffe          BL       GPIO_ResetBits
;;;175      MSD_WriteByte(CMD_READ);
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       MSD_WriteByte
;;;176       /* Send ReadAddr high nibble address byte to read from */
;;;177      MSD_WriteByte((ReadAddr & 0xFF0000) >> 16);
00001e  f3c44007          UBFX     r0,r4,#16,#8
000022  f7fffffe          BL       MSD_WriteByte
;;;178      /* Send ReadAddr medium nibble address byte to read from */
;;;179      MSD_WriteByte((ReadAddr& 0xFF00) >> 8);
000026  f3c42007          UBFX     r0,r4,#8,#8
00002a  f7fffffe          BL       MSD_WriteByte
;;;180      /* Send ReadAddr low nibble address byte to read from */
;;;181      MSD_WriteByte(ReadAddr & 0xFF);
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       MSD_WriteByte
;;;182    
;;;183          /* Read the MSD block data : read NumByteToRead data */
;;;184          for (i = 0; i < NumByteToRead; i++)
000034  bf00              NOP      
000036  e004              B        |L6.66|
                  |L6.56|
;;;185          {
;;;186            /* Save the received data */
;;;187            *pBuffer = MSD_ReadByte();
000038  f7fffffe          BL       MSD_ReadByte
00003c  7028              STRB     r0,[r5,#0]
;;;188            /* Point to the next location where the byte read will be saved */
;;;189            pBuffer++;
00003e  1c6d              ADDS     r5,r5,#1
000040  1c7f              ADDS     r7,r7,#1              ;184
                  |L6.66|
000042  42b7              CMP      r7,r6                 ;184
000044  d3f8              BCC      |L6.56|
;;;190          }
;;;191          /* Set response value to success */
;;;192          rvalue = MSD_RESPONSE_NO_ERROR;
000046  f04f0800          MOV      r8,#0
;;;193    
;;;194      /* MSD chip select high */
;;;195      MSD_CS_HIGH();
00004a  2110              MOVS     r1,#0x10
00004c  4802              LDR      r0,|L6.88|
00004e  f7fffffe          BL       GPIO_SetBits
;;;196    
;;;197      return rvalue;
000052  4640              MOV      r0,r8
;;;198    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;199    
                          ENDP

                  |L6.88|
                          DCD      0x40010800

                          AREA ||i.MSD_ReadBuffer||, CODE, READONLY, ALIGN=1

                  MSD_ReadBuffer PROC
;;;280    *******************************************************************************/
;;;281    uint8_t MSD_ReadBuffer(uint8_t* pBuffer, uint32_t ReadAddr, uint32_t NumByteToRead)
000000  b570              PUSH     {r4-r6,lr}
;;;282    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;283      return MSD_ReadBlock(pBuffer,ReadAddr,NumByteToRead);
000008  b2a2              UXTH     r2,r4
00000a  4631              MOV      r1,r6
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       MSD_ReadBlock
;;;284    }
000012  bd70              POP      {r4-r6,pc}
;;;285    
                          ENDP


                          AREA ||i.MSD_ReadByte||, CODE, READONLY, ALIGN=2

                  MSD_ReadByte PROC
;;;480    *******************************************************************************/
;;;481    uint8_t MSD_ReadByte(void)
000000  b510              PUSH     {r4,lr}
;;;482    {
;;;483      uint8_t Data = 0;
000002  2400              MOVS     r4,#0
;;;484    
;;;485      /* Wait until the transmit buffer is empty */
;;;486      while (SPI_I2S_GetFlagStatus(MSD_SPI, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L8.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L8.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L8.6|
;;;487      /* Send the byte */
;;;488      SPI_I2S_SendData(MSD_SPI, DUMMY_BYTE);
000012  21a5              MOVS     r1,#0xa5
000014  4807              LDR      r0,|L8.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;489    
;;;490      /* Wait until a data is received */
;;;491      while (SPI_I2S_GetFlagStatus(MSD_SPI, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L8.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L8.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L8.28|
;;;492      /* Get the received data */
;;;493      Data = SPI_I2S_ReceiveData(MSD_SPI);
000028  4802              LDR      r0,|L8.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c4              UXTB     r4,r0
;;;494    
;;;495      /* Return the shifted data */
;;;496      return Data;
000030  4620              MOV      r0,r4
;;;497    }
000032  bd10              POP      {r4,pc}
;;;498    
                          ENDP

                  |L8.52|
                          DCD      0x40013000

                          AREA ||i.MSD_SendCmd||, CODE, READONLY, ALIGN=1

                  MSD_SendCmd PROC
;;;298    *******************************************************************************/
;;;299    void MSD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;300    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;301      uint32_t i = 0x00;
00000a  2500              MOVS     r5,#0
;;;302      uint8_t Frame[6];
;;;303    
;;;304      /* Construct byte1 */
;;;305      Frame[0] = (Cmd | 0x40);
00000c  f0460040          ORR      r0,r6,#0x40
000010  f88d0000          STRB     r0,[sp,#0]
;;;306      /* Construct byte2 */
;;;307      Frame[1] = (uint8_t)(Arg >> 24);
000014  0e20              LSRS     r0,r4,#24
000016  f88d0001          STRB     r0,[sp,#1]
;;;308      /* Construct byte3 */
;;;309      Frame[2] = (uint8_t)(Arg >> 16);
00001a  0c20              LSRS     r0,r4,#16
00001c  f88d0002          STRB     r0,[sp,#2]
;;;310      /* Construct byte4 */
;;;311      Frame[3] = (uint8_t)(Arg >> 8);
000020  0a20              LSRS     r0,r4,#8
000022  f88d0003          STRB     r0,[sp,#3]
;;;312      /* Construct byte5 */
;;;313      Frame[4] = (uint8_t)(Arg);
000026  b2e0              UXTB     r0,r4
000028  f88d0004          STRB     r0,[sp,#4]
;;;314      /* Construct CRC: byte6 */
;;;315      Frame[5] = (Crc);
00002c  f88d7005          STRB     r7,[sp,#5]
;;;316    
;;;317      /* Send the Cmd bytes */
;;;318      for (i = 0; i < 6; i++)
000030  bf00              NOP      
000032  e004              B        |L9.62|
                  |L9.52|
;;;319      {
;;;320        MSD_WriteByte(Frame[i]);
000034  f81d0005          LDRB     r0,[sp,r5]
000038  f7fffffe          BL       MSD_WriteByte
00003c  1c6d              ADDS     r5,r5,#1              ;318
                  |L9.62|
00003e  2d06              CMP      r5,#6                 ;318
000040  d3f8              BCC      |L9.52|
;;;321      }
;;;322    }
000042  e8bd81fc          POP      {r2-r8,pc}
;;;323    
                          ENDP


                          AREA ||i.MSD_WriteBlock||, CODE, READONLY, ALIGN=2

                  MSD_WriteBlock PROC
;;;140    *******************************************************************************/
;;;141    uint8_t MSD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;143      uint8_t rvalue = MSD_RESPONSE_FAILURE;
00000a  27ff              MOVS     r7,#0xff
;;;144      MSD_ReadBuffer(VerString, WriteAddr, 16);
00000c  2210              MOVS     r2,#0x10
00000e  4621              MOV      r1,r4
000010  480a              LDR      r0,|L10.60|
000012  f7fffffe          BL       MSD_ReadBuffer
;;;145    
;;;146      if( 0 == Buffercmp(CmpString,VerString,16))
000016  2210              MOVS     r2,#0x10
000018  4908              LDR      r1,|L10.60|
00001a  4809              LDR      r0,|L10.64|
00001c  f7fffffe          BL       Buffercmp
000020  b910              CBNZ     r0,|L10.40|
;;;147      {
;;;148      	SPI_FLASH_SectorErase(WriteAddr);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       SPI_FLASH_SectorErase
                  |L10.40|
;;;149      }
;;;150      SPI_FLASH_BufferWrite(pBuffer, WriteAddr, NumByteToWrite);
000028  4632              MOV      r2,r6
00002a  4621              MOV      r1,r4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SPI_FLASH_BufferWrite
;;;151    
;;;152      rvalue = MSD_RESPONSE_NO_ERROR;
000032  2700              MOVS     r7,#0
;;;153    
;;;154      return rvalue;
000034  4638              MOV      r0,r7
;;;155    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;156    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      VerString
                  |L10.64|
                          DCD      CmpString

                          AREA ||i.MSD_WriteBuffer||, CODE, READONLY, ALIGN=2

                  MSD_WriteBuffer PROC
;;;210    *******************************************************************************/
;;;211    uint8_t MSD_WriteBuffer(uint8_t* pBuffer, uint32_t WriteAddr, uint32_t NumByteToWrite)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;212    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;213      uint32_t i = 0, NbrOfBlock = 0, Offset = 0;
00000a  2700              MOVS     r7,#0
00000c  46b9              MOV      r9,r7
00000e  46b8              MOV      r8,r7
;;;214      uint8_t rvalue = MSD_RESPONSE_FAILURE;
000010  f04f0aff          MOV      r10,#0xff
;;;215    
;;;216      /* Calculate number of blocks to write */
;;;217      NbrOfBlock = NumByteToWrite / BLOCK_SIZE;
000014  ea4f2956          LSR      r9,r6,#9
;;;218      /* MSD chip select low */
;;;219      MSD_CS_LOW();
000018  2110              MOVS     r1,#0x10
00001a  481f              LDR      r0,|L11.152|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;220    
;;;221      /* Data transfer */
;;;222      while (NbrOfBlock --)
000020  e02b              B        |L11.122|
                  |L11.34|
;;;223      {
;;;224        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
;;;225        MSD_SendCmd(MSD_WRITE_BLOCK, WriteAddr + Offset, 0xFF);
000022  eb050108          ADD      r1,r5,r8
000026  22ff              MOVS     r2,#0xff
000028  2018              MOVS     r0,#0x18
00002a  f7fffffe          BL       MSD_SendCmd
;;;226    
;;;227        /* Check if the MSD acknowledged the write block command: R1 response (0x00: no errors) */
;;;228        if (MSD_GetResponse(MSD_RESPONSE_NO_ERROR))
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       MSD_GetResponse
000034  b110              CBZ      r0,|L11.60|
;;;229        {
;;;230          return MSD_RESPONSE_FAILURE;
000036  20ff              MOVS     r0,#0xff
                  |L11.56|
;;;231        }
;;;232        /* Send dummy byte */
;;;233        MSD_WriteByte(DUMMY_BYTE);
;;;234        /* Send the data token to signify the start of the data */
;;;235        MSD_WriteByte(MSD_START_DATA_SINGLE_BLOCK_WRITE);
;;;236        /* Write the block data to MSD : write count data by block */
;;;237        for (i = 0; i < BLOCK_SIZE; i++)
;;;238        {
;;;239          /* Send the pointed byte */
;;;240          MSD_WriteByte(*pBuffer);
;;;241          /* Point to the next location where the byte read will be saved */
;;;242          pBuffer++;
;;;243        }
;;;244        /* Set next write address */
;;;245        Offset += 512;
;;;246        /* Put CRC bytes (not really needed by us, but required by MSD) */
;;;247        MSD_ReadByte();
;;;248        MSD_ReadByte();
;;;249        /* Read data response */
;;;250        if (MSD_GetDataResponse() == MSD_DATA_OK)
;;;251        {
;;;252          /* Set response value to success */
;;;253          rvalue = MSD_RESPONSE_NO_ERROR;
;;;254        }
;;;255        else
;;;256        {
;;;257          /* Set response value to failure */
;;;258          rvalue = MSD_RESPONSE_FAILURE;
;;;259        }
;;;260      }
;;;261    
;;;262      /* MSD chip select high */
;;;263      MSD_CS_HIGH();
;;;264      /* Send dummy byte: 8 Clock pulses of delay */
;;;265      MSD_WriteByte(DUMMY_BYTE);
;;;266      /* Returns the reponse */
;;;267      return rvalue;
;;;268    }
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L11.60|
00003c  20a5              MOVS     r0,#0xa5              ;233
00003e  f7fffffe          BL       MSD_WriteByte
000042  20fe              MOVS     r0,#0xfe              ;235
000044  f7fffffe          BL       MSD_WriteByte
000048  2700              MOVS     r7,#0                 ;237
00004a  e004              B        |L11.86|
                  |L11.76|
00004c  7820              LDRB     r0,[r4,#0]            ;240
00004e  f7fffffe          BL       MSD_WriteByte
000052  1c64              ADDS     r4,r4,#1              ;242
000054  1c7f              ADDS     r7,r7,#1              ;237
                  |L11.86|
000056  f5b77f00          CMP      r7,#0x200             ;237
00005a  d3f7              BCC      |L11.76|
00005c  f5087800          ADD      r8,r8,#0x200          ;245
000060  f7fffffe          BL       MSD_ReadByte
000064  f7fffffe          BL       MSD_ReadByte
000068  f7fffffe          BL       MSD_GetDataResponse
00006c  2805              CMP      r0,#5                 ;250
00006e  d102              BNE      |L11.118|
000070  f04f0a00          MOV      r10,#0                ;253
000074  e001              B        |L11.122|
                  |L11.118|
000076  f04f0aff          MOV      r10,#0xff             ;258
                  |L11.122|
00007a  ea5f0009          MOVS     r0,r9                 ;222
00007e  f1a90901          SUB      r9,r9,#1              ;222
000082  d1ce              BNE      |L11.34|
000084  2110              MOVS     r1,#0x10              ;263
000086  4804              LDR      r0,|L11.152|
000088  f7fffffe          BL       GPIO_SetBits
00008c  20a5              MOVS     r0,#0xa5              ;265
00008e  f7fffffe          BL       MSD_WriteByte
000092  4650              MOV      r0,r10                ;267
000094  e7d0              B        |L11.56|
;;;269    
                          ENDP

000096  0000              DCW      0x0000
                  |L11.152|
                          DCD      0x40010800

                          AREA ||i.MSD_WriteByte||, CODE, READONLY, ALIGN=2

                  MSD_WriteByte PROC
;;;459    *******************************************************************************/
;;;460    void MSD_WriteByte(uint8_t Data)
000000  b510              PUSH     {r4,lr}
;;;461    {
000002  4604              MOV      r4,r0
;;;462      /* Wait until the transmit buffer is empty */
;;;463      while (SPI_I2S_GetFlagStatus(MSD_SPI, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L12.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L12.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L12.6|
;;;464      /* Send the byte */
;;;465      SPI_I2S_SendData(MSD_SPI, Data);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L12.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;466    
;;;467      /* Wait until a data is received */
;;;468      while (SPI_I2S_GetFlagStatus(MSD_SPI, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L12.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L12.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L12.28|
;;;469      /* Get the received data */
;;;470      SPI_I2S_ReceiveData(MSD_SPI);
000028  4801              LDR      r0,|L12.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;471      
;;;472    }
00002e  bd10              POP      {r4,pc}
;;;473    
                          ENDP

                  |L12.48|
                          DCD      0x40013000

                          AREA ||i.SPI_FLASH_BufferWrite||, CODE, READONLY, ALIGN=1

                  SPI_FLASH_BufferWrite PROC
;;;730    
;;;731     void SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;732    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;733      uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2500              MOVS     r5,#0
000014  46ab              MOV      r11,r5
;;;734    
;;;735      Addr = WriteAddr % SPI_FLASH_PAGESIZE;
000016  f0060aff          AND      r10,r6,#0xff
;;;736      count = SPI_FLASH_PAGESIZE - Addr;
00001a  f1ca0000          RSB      r0,r10,#0
00001e  b2c5              UXTB     r5,r0
;;;737      NumOfPage =  NumByteToWrite / SPI_FLASH_PAGESIZE;
000020  4620              MOV      r0,r4
000022  17e1              ASRS     r1,r4,#31
000024  eb046111          ADD      r1,r4,r1,LSR #24
000028  f3c12807          UBFX     r8,r1,#8,#8
;;;738      NumOfSingle = NumByteToWrite % SPI_FLASH_PAGESIZE;
00002c  17e1              ASRS     r1,r4,#31
00002e  eb046111          ADD      r1,r4,r1,LSR #24
000032  1209              ASRS     r1,r1,#8
000034  eba42101          SUB      r1,r4,r1,LSL #8
000038  f00109ff          AND      r9,r1,#0xff
;;;739    
;;;740      if (Addr == 0) /* WriteAddr is SPI_FLASH_PAGESIZE aligned  */
00003c  f1ba0f00          CMP      r10,#0
000040  d120              BNE      |L13.132|
;;;741      {
;;;742        if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PAGESIZE */
000042  f1b80f00          CMP      r8,#0
000046  d105              BNE      |L13.84|
;;;743        {
;;;744          SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
000048  4622              MOV      r2,r4
00004a  4631              MOV      r1,r6
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       SPI_FLASH_PageWrite
000052  e064              B        |L13.286|
                  |L13.84|
;;;745        }
;;;746        else /* NumByteToWrite > SPI_FLASH_PAGESIZE */
;;;747        {
;;;748          while (NumOfPage--)
000054  e009              B        |L13.106|
                  |L13.86|
;;;749          {
;;;750            SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PAGESIZE);
000056  f44f7280          MOV      r2,#0x100
00005a  4631              MOV      r1,r6
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       SPI_FLASH_PageWrite
;;;751            WriteAddr +=  SPI_FLASH_PAGESIZE;
000062  f5067680          ADD      r6,r6,#0x100
;;;752            pBuffer += SPI_FLASH_PAGESIZE;
000066  f5077780          ADD      r7,r7,#0x100
                  |L13.106|
00006a  ea5f0008          MOVS     r0,r8                 ;748
00006e  f1a80101          SUB      r1,r8,#1              ;748
000072  f00108ff          AND      r8,r1,#0xff           ;748
000076  d1ee              BNE      |L13.86|
;;;753          }
;;;754    
;;;755          SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
000078  464a              MOV      r2,r9
00007a  4631              MOV      r1,r6
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       SPI_FLASH_PageWrite
000082  e04c              B        |L13.286|
                  |L13.132|
;;;756        }
;;;757      }
;;;758      else /* WriteAddr is not SPI_FLASH_PAGESIZE aligned  */
;;;759      {
;;;760        if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PAGESIZE */
000084  f1b80f00          CMP      r8,#0
000088  d118              BNE      |L13.188|
;;;761        {
;;;762          if (NumOfSingle > count) /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PAGESIZE */
00008a  45a9              CMP      r9,r5
00008c  dd10              BLE      |L13.176|
;;;763          {
;;;764            temp = NumOfSingle - count;
00008e  eba90005          SUB      r0,r9,r5
000092  f0000bff          AND      r11,r0,#0xff
;;;765    
;;;766            SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
000096  462a              MOV      r2,r5
000098  4631              MOV      r1,r6
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       SPI_FLASH_PageWrite
;;;767            WriteAddr +=  count;
0000a0  442e              ADD      r6,r6,r5
;;;768            pBuffer += count;
0000a2  442f              ADD      r7,r7,r5
;;;769    
;;;770            SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
0000a4  465a              MOV      r2,r11
0000a6  4631              MOV      r1,r6
0000a8  4638              MOV      r0,r7
0000aa  f7fffffe          BL       SPI_FLASH_PageWrite
0000ae  e036              B        |L13.286|
                  |L13.176|
;;;771          }
;;;772          else
;;;773          {
;;;774            SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
0000b0  4622              MOV      r2,r4
0000b2  4631              MOV      r1,r6
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       SPI_FLASH_PageWrite
0000ba  e030              B        |L13.286|
                  |L13.188|
;;;775          }
;;;776        }
;;;777        else /* NumByteToWrite > SPI_FLASH_PAGESIZE */
;;;778        {
;;;779          NumByteToWrite -= count;
0000bc  1b60              SUBS     r0,r4,r5
0000be  b284              UXTH     r4,r0
;;;780          NumOfPage =  NumByteToWrite / SPI_FLASH_PAGESIZE;
0000c0  4620              MOV      r0,r4
0000c2  17e1              ASRS     r1,r4,#31
0000c4  eb046111          ADD      r1,r4,r1,LSR #24
0000c8  f3c12807          UBFX     r8,r1,#8,#8
;;;781          NumOfSingle = NumByteToWrite % SPI_FLASH_PAGESIZE;
0000cc  17e1              ASRS     r1,r4,#31
0000ce  eb046111          ADD      r1,r4,r1,LSR #24
0000d2  1209              ASRS     r1,r1,#8
0000d4  eba42101          SUB      r1,r4,r1,LSL #8
0000d8  f00109ff          AND      r9,r1,#0xff
;;;782    
;;;783          SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
0000dc  462a              MOV      r2,r5
0000de  4631              MOV      r1,r6
0000e0  4638              MOV      r0,r7
0000e2  f7fffffe          BL       SPI_FLASH_PageWrite
;;;784          WriteAddr +=  count;
0000e6  442e              ADD      r6,r6,r5
;;;785          pBuffer += count;
0000e8  442f              ADD      r7,r7,r5
;;;786    
;;;787          while (NumOfPage--)
0000ea  e009              B        |L13.256|
                  |L13.236|
;;;788          {
;;;789            SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PAGESIZE);
0000ec  f44f7280          MOV      r2,#0x100
0000f0  4631              MOV      r1,r6
0000f2  4638              MOV      r0,r7
0000f4  f7fffffe          BL       SPI_FLASH_PageWrite
;;;790            WriteAddr +=  SPI_FLASH_PAGESIZE;
0000f8  f5067680          ADD      r6,r6,#0x100
;;;791            pBuffer += SPI_FLASH_PAGESIZE;
0000fc  f5077780          ADD      r7,r7,#0x100
                  |L13.256|
000100  ea5f0008          MOVS     r0,r8                 ;787
000104  f1a80101          SUB      r1,r8,#1              ;787
000108  f00108ff          AND      r8,r1,#0xff           ;787
00010c  d1ee              BNE      |L13.236|
;;;792          }
;;;793    
;;;794          if (NumOfSingle != 0)
00010e  f1b90f00          CMP      r9,#0
000112  d004              BEQ      |L13.286|
;;;795          {
;;;796            SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
000114  464a              MOV      r2,r9
000116  4631              MOV      r1,r6
000118  4638              MOV      r0,r7
00011a  f7fffffe          BL       SPI_FLASH_PageWrite
                  |L13.286|
;;;797          }
;;;798        }
;;;799      }
;;;800    }
00011e  e8bd9ff0          POP      {r4-r12,pc}
;;;801    
                          ENDP


                          AREA ||i.SPI_FLASH_ChipErase||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ChipErase PROC
;;;106    
;;;107    void SPI_FLASH_ChipErase()
000000  b510              PUSH     {r4,lr}
;;;108    {  SPI_FLASH_WriteEnable();
000002  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;109       MSD_CS_LOW();
000006  2110              MOVS     r1,#0x10
000008  4806              LDR      r0,|L14.36|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;110       MSD_WriteByte(CMD_BE);
00000e  20c7              MOVS     r0,#0xc7
000010  f7fffffe          BL       MSD_WriteByte
;;;111       MSD_CS_HIGH();
000014  2110              MOVS     r1,#0x10
000016  4803              LDR      r0,|L14.36|
000018  f7fffffe          BL       GPIO_SetBits
;;;112       SPI_FLASH_WaitForWriteEnd();
00001c  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;113    }
000020  bd10              POP      {r4,pc}
;;;114    
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_GlobalProtect||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_GlobalProtect PROC
;;;93     
;;;94     void SPI_FLASH_GlobalProtect()
000000  b570              PUSH     {r4-r6,lr}
;;;95     { 
;;;96     	uint8_t StatusByte0 = MSD_GetStatus();
000002  f7fffffe          BL       MSD_GetStatus
000006  b2c4              UXTB     r4,r0
;;;97     	uint8_t StatusByte1 = 0;
000008  2500              MOVS     r5,#0
;;;98     	SPI_FLASH_WriteEnable();
00000a  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;99     	MSD_CS_LOW();
00000e  2110              MOVS     r1,#0x10
000010  4809              LDR      r0,|L15.56|
000012  f7fffffe          BL       GPIO_ResetBits
;;;100    	MSD_WriteByte(CMD_WRSR);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       MSD_WriteByte
;;;101    	MSD_WriteByte(GLOPS | StatusByte0);
00001c  f0440018          ORR      r0,r4,#0x18
000020  f7fffffe          BL       MSD_WriteByte
;;;102    	MSD_WriteByte(StatusByte1);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       MSD_WriteByte
;;;103    	MSD_CS_HIGH();
00002a  2110              MOVS     r1,#0x10
00002c  4802              LDR      r0,|L15.56|
00002e  f7fffffe          BL       GPIO_SetBits
;;;104    	SPI_FLASH_WaitForWriteEnd();
000032  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;105    }
000036  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP

                  |L15.56|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_GlobalUnprotect||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_GlobalUnprotect PROC
;;;79     
;;;80     void SPI_FLASH_GlobalUnprotect()
000000  b570              PUSH     {r4-r6,lr}
;;;81     { 
;;;82     	uint8_t StatusByte0 = MSD_GetStatus();
000002  f7fffffe          BL       MSD_GetStatus
000006  b2c4              UXTB     r4,r0
;;;83     	uint8_t StatusByte1 = 0;
000008  2500              MOVS     r5,#0
;;;84     	SPI_FLASH_WriteEnable();
00000a  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;85     	
;;;86     	MSD_CS_LOW();
00000e  2110              MOVS     r1,#0x10
000010  4809              LDR      r0,|L16.56|
000012  f7fffffe          BL       GPIO_ResetBits
;;;87     	MSD_WriteByte(CMD_WRSR);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       MSD_WriteByte
;;;88     	MSD_WriteByte(GLOUPS & StatusByte0);
00001c  f00400e3          AND      r0,r4,#0xe3
000020  f7fffffe          BL       MSD_WriteByte
;;;89     	MSD_WriteByte(StatusByte1);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       MSD_WriteByte
;;;90     	MSD_CS_HIGH();
00002a  2110              MOVS     r1,#0x10
00002c  4802              LDR      r0,|L16.56|
00002e  f7fffffe          BL       GPIO_SetBits
;;;91     	SPI_FLASH_WaitForWriteEnd();
000032  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;92     }
000036  bd70              POP      {r4-r6,pc}
;;;93     
                          ENDP

                  |L16.56|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_PageWrite||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_PageWrite PROC
;;;697    
;;;698    void SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
000000  b570              PUSH     {r4-r6,lr}
;;;699    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;700      /* Enable the write access to the FLASH */
;;;701      SPI_FLASH_WriteEnable();
000008  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;702    
;;;703      /* Select the FLASH: Chip Select low */
;;;704      MSD_CS_LOW();
00000c  2110              MOVS     r1,#0x10
00000e  4811              LDR      r0,|L17.84|
000010  f7fffffe          BL       GPIO_ResetBits
;;;705      /* Send "Write to Memory " instruction */
;;;706      MSD_WriteByte(CMD_WRITE);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       MSD_WriteByte
;;;707      /* Send WriteAddr high nibble address byte to write to */
;;;708      MSD_WriteByte((WriteAddr & 0xFF0000) >> 16);
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       MSD_WriteByte
;;;709      /* Send WriteAddr medium nibble address byte to write to */
;;;710      MSD_WriteByte((WriteAddr & 0xFF00) >> 8);
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       MSD_WriteByte
;;;711      /* Send WriteAddr low nibble address byte to write to */
;;;712      MSD_WriteByte(WriteAddr & 0xFF);
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       MSD_WriteByte
;;;713    
;;;714      /* while there is data to be written on the FLASH */
;;;715      while (NumByteToWrite--)
000030  e003              B        |L17.58|
                  |L17.50|
;;;716      {
;;;717        /* Send the current byte */
;;;718        MSD_WriteByte(*pBuffer);
000032  7828              LDRB     r0,[r5,#0]
000034  f7fffffe          BL       MSD_WriteByte
;;;719        /* Point on the next byte to be written */
;;;720        pBuffer++;
000038  1c6d              ADDS     r5,r5,#1
                  |L17.58|
00003a  0030              MOVS     r0,r6                 ;715
00003c  f1a60101          SUB      r1,r6,#1              ;715
000040  b28e              UXTH     r6,r1                 ;715
000042  d1f6              BNE      |L17.50|
;;;721      }
;;;722    
;;;723      /* Deselect the FLASH: Chip Select high */
;;;724      MSD_CS_HIGH();
000044  2110              MOVS     r1,#0x10
000046  4803              LDR      r0,|L17.84|
000048  f7fffffe          BL       GPIO_SetBits
;;;725    
;;;726      /* Wait the end of Flash writing */
;;;727      SPI_FLASH_WaitForWriteEnd();
00004c  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;728    }
000050  bd70              POP      {r4-r6,pc}
;;;729    
                          ENDP

000052  0000              DCW      0x0000
                  |L17.84|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_ReadID||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_ReadID PROC
;;;580    
;;;581     uint32_t SPI_FLASH_ReadID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;582    {
;;;583      uint32_t Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0,Temp3 = 0;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
00000c  46a0              MOV      r8,r4
;;;584    
;;;585      /* Select the FLASH: Chip Select low */
;;;586      MSD_CS_LOW();
00000e  2110              MOVS     r1,#0x10
000010  480f              LDR      r0,|L18.80|
000012  f7fffffe          BL       GPIO_ResetBits
;;;587    
;;;588      /* Send "RDID " instruction */
;;;589      MSD_WriteByte(CMD_RDID);
000016  209f              MOVS     r0,#0x9f
000018  f7fffffe          BL       MSD_WriteByte
;;;590    
;;;591      /* Read a byte from the FLASH */
;;;592      Temp0 = MSD_ReadByte();
00001c  f7fffffe          BL       MSD_ReadByte
000020  4605              MOV      r5,r0
;;;593    
;;;594      /* Read a byte from the FLASH */
;;;595      Temp1 = MSD_ReadByte();
000022  f7fffffe          BL       MSD_ReadByte
000026  4606              MOV      r6,r0
;;;596    
;;;597      /* Read a byte from the FLASH */
;;;598      Temp2 = MSD_ReadByte();
000028  f7fffffe          BL       MSD_ReadByte
00002c  4607              MOV      r7,r0
;;;599    
;;;600      Temp3 = MSD_ReadByte();
00002e  f7fffffe          BL       MSD_ReadByte
000032  4680              MOV      r8,r0
;;;601    
;;;602      /* Deselect the FLASH: Chip Select high */
;;;603      MSD_CS_HIGH();
000034  2110              MOVS     r1,#0x10
000036  4806              LDR      r0,|L18.80|
000038  f7fffffe          BL       GPIO_SetBits
;;;604    
;;;605      Temp = (Temp0 << 24)|(Temp1 << 16) | (Temp2 << 8) | Temp3;
00003c  0628              LSLS     r0,r5,#24
00003e  ea404006          ORR      r0,r0,r6,LSL #16
000042  ea402007          ORR      r0,r0,r7,LSL #8
000046  ea400408          ORR      r4,r0,r8
;;;606    
;;;607      return Temp;
00004a  4620              MOV      r0,r4
;;;608    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;609    
                          ENDP

                  |L18.80|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_SectorErase||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SectorErase PROC
;;;646    //#define SPI_FLASH_PAGESIZE    256
;;;647    void SPI_FLASH_SectorErase(uint32_t SectorAddr)
000000  b510              PUSH     {r4,lr}
;;;648    {
000002  4604              MOV      r4,r0
;;;649      /* Send write enable instruction */
;;;650    
;;;651      SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;652       
;;;653      /* Sector Erase */
;;;654      /* Select the FLASH: Chip Select low */
;;;655      
;;;656      MSD_CS_LOW();
000008  2110              MOVS     r1,#0x10
00000a  480c              LDR      r0,|L19.60|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;657      /* Send Sector Erase instruction */
;;;658      MSD_WriteByte(CMD_SE);
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       MSD_WriteByte
;;;659      /* Send SectorAddr high nibble address byte */
;;;660      MSD_WriteByte((SectorAddr & 0xFF0000) >> 16);
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       MSD_WriteByte
;;;661      /* Send SectorAddr medium nibble address byte */
;;;662      MSD_WriteByte((SectorAddr & 0xFF00) >> 8);
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       MSD_WriteByte
;;;663      /* Send SectorAddr low nibble address byte */
;;;664      MSD_WriteByte(SectorAddr & 0xFF);
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       MSD_WriteByte
;;;665      /* Deselect the FLASH: Chip Select high */
;;;666      MSD_CS_HIGH();
00002c  2110              MOVS     r1,#0x10
00002e  4803              LDR      r0,|L19.60|
000030  f7fffffe          BL       GPIO_SetBits
;;;667    
;;;668      /* Wait the end of Flash writing */
;;;669      SPI_FLASH_WaitForWriteEnd();
000034  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;670    }
000038  bd10              POP      {r4,pc}
;;;671    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_SectorUnprotect||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_SectorUnprotect PROC
;;;622    
;;;623    void SPI_FLASH_SectorUnprotect(uint32_t SectorAddr)
000000  b510              PUSH     {r4,lr}
;;;624    {
000002  4604              MOV      r4,r0
;;;625      SPI_FLASH_WriteEnable();
000004  f7fffffe          BL       SPI_FLASH_WriteEnable
;;;626       
;;;627      /* Sector Erase */
;;;628      /* Select the FLASH: Chip Select low */
;;;629      
;;;630      MSD_CS_LOW();
000008  2110              MOVS     r1,#0x10
00000a  480c              LDR      r0,|L20.60|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;631      /* Send Sector Erase instruction */
;;;632      MSD_WriteByte(CMD_UPS);
000010  2039              MOVS     r0,#0x39
000012  f7fffffe          BL       MSD_WriteByte
;;;633      /* Send SectorAddr high nibble address byte */
;;;634      MSD_WriteByte((SectorAddr & 0xFF0000) >> 16);
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       MSD_WriteByte
;;;635      /* Send SectorAddr medium nibble address byte */
;;;636      MSD_WriteByte((SectorAddr & 0xFF00) >> 8);
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       MSD_WriteByte
;;;637      /* Send SectorAddr low nibble address byte */
;;;638      MSD_WriteByte(SectorAddr & 0xFF);
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       MSD_WriteByte
;;;639      /* Deselect the FLASH: Chip Select high */
;;;640      MSD_CS_HIGH();
00002c  2110              MOVS     r1,#0x10
00002e  4803              LDR      r0,|L20.60|
000030  f7fffffe          BL       GPIO_SetBits
;;;641    
;;;642      /* Wait the end of Flash writing */
;;;643      SPI_FLASH_WaitForWriteEnd();
000034  f7fffffe          BL       SPI_FLASH_WaitForWriteEnd
;;;644    }
000038  bd10              POP      {r4,pc}
;;;645    //#define BLOCK_SIZE    512
                          ENDP

00003a  0000              DCW      0x0000
                  |L20.60|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WaitForWriteEnd PROC
;;;673    
;;;674    void SPI_FLASH_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;675    {
;;;676      uint8_t flashstatus = 0;
000002  2400              MOVS     r4,#0
;;;677    
;;;678      /* Select the FLASH: Chip Select low */
;;;679      MSD_CS_LOW();
000004  2110              MOVS     r1,#0x10
000006  4809              LDR      r0,|L21.44|
000008  f7fffffe          BL       GPIO_ResetBits
;;;680    
;;;681      /* Send "Read Status Register" instruction */
;;;682      MSD_WriteByte(CMD_RDSR);
00000c  2005              MOVS     r0,#5
00000e  f7fffffe          BL       MSD_WriteByte
;;;683    
;;;684      /* Loop as long as the memory is busy with a write cycle */
;;;685      do
000012  bf00              NOP      
                  |L21.20|
;;;686      {
;;;687        /* Send a dummy byte to generate the clock needed by the FLASH
;;;688        and put the value of the status register in FLASH_Status variable */
;;;689        flashstatus = MSD_ReadByte();
000014  f7fffffe          BL       MSD_ReadByte
000018  4604              MOV      r4,r0
;;;690    
;;;691      }
;;;692      while ((flashstatus & WIP_FLAG) == SET);/* Write in progress */
00001a  f0040001          AND      r0,r4,#1
00001e  2800              CMP      r0,#0
000020  d1f8              BNE      |L21.20|
;;;693    
;;;694      /* Deselect the FLASH: Chip Select high */
;;;695      MSD_CS_HIGH();
000022  2110              MOVS     r1,#0x10
000024  4801              LDR      r0,|L21.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;696    }
00002a  bd10              POP      {r4,pc}
;;;697    
                          ENDP

                  |L21.44|
                          DCD      0x40010800

                          AREA ||i.SPI_FLASH_WriteEnable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_WriteEnable PROC
;;;610    
;;;611    void SPI_FLASH_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;612    {
;;;613      /* Select the FLASH: Chip Select low */
;;;614      MSD_CS_LOW();
000002  2110              MOVS     r1,#0x10
000004  4805              LDR      r0,|L22.28|
000006  f7fffffe          BL       GPIO_ResetBits
;;;615    
;;;616      /* Send "Write Enable" instruction */
;;;617      MSD_WriteByte(CMD_WREN);
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       MSD_WriteByte
;;;618    
;;;619      /* Deselect the FLASH: Chip Select high */
;;;620      MSD_CS_HIGH();
000010  2110              MOVS     r1,#0x10
000012  4802              LDR      r0,|L22.28|
000014  f7fffffe          BL       GPIO_SetBits
;;;621    }
000018  bd10              POP      {r4,pc}
;;;622    
                          ENDP

00001a  0000              DCW      0x0000
                  |L22.28|
                          DCD      0x40010800

                          AREA ||i.SPI_Flash_Config||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Config PROC
;;;505    *******************************************************************************/
;;;506    void SPI_Flash_Config(void)
000000  b500              PUSH     {lr}
;;;507    {
000002  b087              SUB      sp,sp,#0x1c
;;;508      GPIO_InitTypeDef  GPIO_InitStructure;
;;;509      SPI_InitTypeDef   SPI_InitStructure;
;;;510    
;;;511      /* MSD_SPI_PORT and MSD_CS_PORT Periph clock enable */
;;;512    //  RCC_APB2PeriphClockCmd(MSD_SPI_GPIO_PORT_CLOCK | MSD_CS_GPIO_PORT_CLOCK , ENABLE);
;;;513     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;514      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;515    
;;;516      /* MSD_SPI Periph clock enable */
;;;517    #ifdef USE_STM3210B_EVAL
;;;518      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;519    #elif defined (USE_STM3210E_EVAL)
;;;520    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000014  2101              MOVS     r1,#1
000016  0308              LSLS     r0,r1,#12
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;521    #elif defined (USE_STM3210C_EVAL)
;;;522      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);
;;;523    #endif /* USE_STM3210B_EVAL */
;;;524    
;;;525      /* Remap the SPI pins if needed */
;;;526    #ifdef SPI_REMAPPED
;;;527      GPIO_PinRemapConfig(MSD_SPI_GPIO_REMAP, ENABLE);
;;;528    #endif /* SPI_REMAPPED */
;;;529    
;;;530      /* Configure SPI pins: SCK, MISO and MOSI */
;;;531      GPIO_InitStructure.GPIO_Pin = MSD_SPI_PIN_SCK ;
00001c  2020              MOVS     r0,#0x20
00001e  f8ad0018          STRH     r0,[sp,#0x18]
;;;532      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d001b          STRB     r0,[sp,#0x1b]
;;;533      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000028  2003              MOVS     r0,#3
00002a  f88d001a          STRB     r0,[sp,#0x1a]
;;;534      GPIO_Init(MSD_SPI_PORT, &GPIO_InitStructure);
00002e  a906              ADD      r1,sp,#0x18
000030  4829              LDR      r0,|L23.216|
000032  f7fffffe          BL       GPIO_Init
;;;535    	
;;;536    	  /* Configure SPI pins: SCK, MISO and MOSI */
;;;537      GPIO_InitStructure.GPIO_Pin =  MSD_SPI_PIN_MISO ;
000036  2040              MOVS     r0,#0x40
000038  f8ad0018          STRH     r0,[sp,#0x18]
;;;538    //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;539      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00003c  2018              MOVS     r0,#0x18
00003e  f88d001b          STRB     r0,[sp,#0x1b]
;;;540      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000042  2003              MOVS     r0,#3
000044  f88d001a          STRB     r0,[sp,#0x1a]
;;;541      GPIO_Init(MSD_SPI_PORT, &GPIO_InitStructure);
000048  a906              ADD      r1,sp,#0x18
00004a  4823              LDR      r0,|L23.216|
00004c  f7fffffe          BL       GPIO_Init
;;;542    	
;;;543    		  /* Configure SPI pins: SCK, MISO and MOSI */
;;;544      GPIO_InitStructure.GPIO_Pin =  MSD_SPI_PIN_MOSI; 
000050  2080              MOVS     r0,#0x80
000052  f8ad0018          STRH     r0,[sp,#0x18]
;;;545      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000056  2018              MOVS     r0,#0x18
000058  f88d001b          STRB     r0,[sp,#0x1b]
;;;546      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005c  2003              MOVS     r0,#3
00005e  f88d001a          STRB     r0,[sp,#0x1a]
;;;547      GPIO_Init(MSD_SPI_PORT, &GPIO_InitStructure);
000062  a906              ADD      r1,sp,#0x18
000064  481c              LDR      r0,|L23.216|
000066  f7fffffe          BL       GPIO_Init
;;;548    	
;;;549    
;;;550      /* Configure I/O for Flash Chip select */
;;;551      GPIO_InitStructure.GPIO_Pin = MSD_CS_PIN;
00006a  2010              MOVS     r0,#0x10
00006c  f8ad0018          STRH     r0,[sp,#0x18]
;;;552      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000070  f88d001b          STRB     r0,[sp,#0x1b]
;;;553      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000074  2003              MOVS     r0,#3
000076  f88d001a          STRB     r0,[sp,#0x1a]
;;;554      GPIO_Init(MSD_CS_PORT, &GPIO_InitStructure);
00007a  a906              ADD      r1,sp,#0x18
00007c  4816              LDR      r0,|L23.216|
00007e  f7fffffe          BL       GPIO_Init
;;;555    
;;;556      //MSD_CS_LOW();
;;;557      MSD_CS_HIGH() ;
000082  2110              MOVS     r1,#0x10
000084  4814              LDR      r0,|L23.216|
000086  f7fffffe          BL       GPIO_SetBits
;;;558      /* MSD_SPI Config */
;;;559      SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
00008a  2000              MOVS     r0,#0
00008c  f8ad0004          STRH     r0,[sp,#4]
;;;560      SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
000090  f44f7082          MOV      r0,#0x104
000094  f8ad0006          STRH     r0,[sp,#6]
;;;561      SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
000098  2000              MOVS     r0,#0
00009a  f8ad0008          STRH     r0,[sp,#8]
;;;562      SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
00009e  2002              MOVS     r0,#2
0000a0  f8ad000a          STRH     r0,[sp,#0xa]
;;;563      SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
0000a4  2001              MOVS     r0,#1
0000a6  f8ad000c          STRH     r0,[sp,#0xc]
;;;564      SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
0000aa  0240              LSLS     r0,r0,#9
0000ac  f8ad000e          STRH     r0,[sp,#0xe]
;;;565      SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
0000b0  2008              MOVS     r0,#8
0000b2  f8ad0010          STRH     r0,[sp,#0x10]
;;;566      SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
0000b6  2000              MOVS     r0,#0
0000b8  f8ad0012          STRH     r0,[sp,#0x12]
;;;567      SPI_InitStructure.SPI_CRCPolynomial = 7;
0000bc  2007              MOVS     r0,#7
0000be  f8ad0014          STRH     r0,[sp,#0x14]
;;;568      SPI_Init(SPI1, &SPI_InitStructure);
0000c2  a901              ADD      r1,sp,#4
0000c4  4805              LDR      r0,|L23.220|
0000c6  f7fffffe          BL       SPI_Init
;;;569    
;;;570      /* MSD_SPI enable */
;;;571      SPI_Cmd(SPI1, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  4803              LDR      r0,|L23.220|
0000ce  f7fffffe          BL       SPI_Cmd
;;;572    }
0000d2  b007              ADD      sp,sp,#0x1c
0000d4  bd00              POP      {pc}
;;;573    /*******************************************************************************
                          ENDP

0000d6  0000              DCW      0x0000
                  |L23.216|
                          DCD      0x40010800
                  |L23.220|
                          DCD      0x40013000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  VerString
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  CmpString
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffffffff          DCB      0xff,0xff,0xff,0xff
000008  ffffffff          DCB      0xff,0xff,0xff,0xff
00000c  ffffffff          DCB      0xff,0xff,0xff,0xff

;*** Start embedded assembler ***

#line 1 "..\\src\\msd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_msd_c_053d2e46____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_msd_c_053d2e46____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_msd_c_053d2e46____REVSH|
#line 144
|__asm___5_msd_c_053d2e46____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
