; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\hw_config.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;168    *******************************************************************************/
;;;169    void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;170    {
;;;171      /* Set the device state to suspend */
;;;172      bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;173    }
000006  4770              BX       lr
;;;174    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=1

                  Get_SerialNum PROC
;;;499    *******************************************************************************/
;;;500    void Get_SerialNum(void)
000000  4770              BX       lr
;;;501    {
;;;502    #if 0
;;;503      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;504    
;;;505      Device_Serial0 = *(uint32_t*)ID1;
;;;506      Device_Serial1 = *(uint32_t*)ID2;
;;;507      Device_Serial2 = *(uint32_t*)ID3;
;;;508    
;;;509      Device_Serial0 += Device_Serial2;
;;;510    
;;;511      if (Device_Serial0 != 0)
;;;512      {
;;;513        IntToUnicode (Device_Serial0, &MASS_StringSerial[2] , 8);
;;;514        IntToUnicode (Device_Serial1, &MASS_StringSerial[18], 4);
;;;515      }
;;;516     #endif
;;;517    }
;;;518    
                          ENDP


                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;525    *******************************************************************************/
;;;526    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;527    {
000002  460b              MOV      r3,r1
;;;528      uint8_t idx = 0;
000004  2100              MOVS     r1,#0
;;;529      
;;;530      for( idx = 0 ; idx < len ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L3.56|
                  |L3.10|
;;;531      {
;;;532        if( ((value >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L3.30|
;;;533        {
;;;534          pbuf[ 2* idx] = (value >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L3.42|
                  |L3.30|
;;;535        }
;;;536        else
;;;537        {
;;;538          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L3.42|
;;;539        }
;;;540        
;;;541        value = value << 4;
00002a  0100              LSLS     r0,r0,#4
;;;542        
;;;543        pbuf[ 2* idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;530
000036  b2e1              UXTB     r1,r4                 ;530
                  |L3.56|
000038  4291              CMP      r1,r2                 ;530
00003a  dbe6              BLT      |L3.10|
;;;544      }
;;;545    }
00003c  bd30              POP      {r4,r5,pc}
;;;546    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;180    *******************************************************************************/
;;;181    void Leave_LowPowerMode(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183      DEVICE_INFO *pInfo = &Device_Info;
000002  4c06              LDR      r4,|L4.28|
;;;184    
;;;185      /* Set the device state to the correct state */
;;;186      if (pInfo->Current_Configuration != 0)
000004  7aa0              LDRB     r0,[r4,#0xa]
000006  b118              CBZ      r0,|L4.16|
;;;187      {
;;;188        /* Device configured */
;;;189        bDeviceState = CONFIGURED;
000008  2005              MOVS     r0,#5
00000a  4905              LDR      r1,|L4.32|
00000c  6008              STR      r0,[r1,#0]  ; bDeviceState
00000e  e002              B        |L4.22|
                  |L4.16|
;;;190      }
;;;191      else
;;;192      {
;;;193        bDeviceState = ATTACHED;
000010  2001              MOVS     r0,#1
000012  4903              LDR      r1,|L4.32|
000014  6008              STR      r0,[r1,#0]  ; bDeviceState
                  |L4.22|
;;;194      }
;;;195      /*Enable SystemCoreClock*/
;;;196      SystemInit(); 
000016  f7fffffe          BL       SystemInit
;;;197    }
00001a  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L4.28|
                          DCD      Device_Info
                  |L4.32|
                          DCD      bDeviceState

                          AREA ||i.Led_Config||, CODE, READONLY, ALIGN=2

                  Led_Config PROC
;;;271    *******************************************************************************/
;;;272    void Led_Config(void)
000000  b508              PUSH     {r3,lr}
;;;273    {
;;;274      /* Configure the LEDs */
;;;275      //STM_EVAL_LEDInit(LED1);
;;;276      //STM_EVAL_LEDInit(LED2);  
;;;277      //STM_EVAL_LEDInit(LED3);
;;;278      //STM_EVAL_LEDInit(LED4);  
;;;279       	GPIO_InitTypeDef  GPIO_InitStructure;
;;;280    
;;;281    	
;;;282    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOA,ENABLE);
000002  2101              MOVS     r1,#1
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;283    	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  482c              LDR      r0,|L5.192|
00000e  f7fffffe          BL       GPIO_PinRemapConfig
;;;284    	
;;;285    
;;;286    	//主板供电配置
;;;287    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
000012  f44f4000          MOV      r0,#0x8000
000016  f8ad0000          STRH     r0,[sp,#0]
;;;288    
;;;289    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;290    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00001e  2002              MOVS     r0,#2
000020  f88d0002          STRB     r0,[sp,#2]
;;;291    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
000024  2010              MOVS     r0,#0x10
000026  f88d0003          STRB     r0,[sp,#3]
;;;292    	GPIO_Init(GPIOB, &GPIO_InitStructure);    
00002a  4669              MOV      r1,sp
00002c  4825              LDR      r0,|L5.196|
00002e  f7fffffe          BL       GPIO_Init
;;;293    	GPIO_SetBits(GPIOB,GPIO_Pin_15);	
000032  f44f4100          MOV      r1,#0x8000
000036  4823              LDR      r0,|L5.196|
000038  f7fffffe          BL       GPIO_SetBits
;;;294        
;;;295    	//SW_CHECK
;;;296    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00003c  2008              MOVS     r0,#8
00003e  f8ad0000          STRH     r0,[sp,#0]
;;;297    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000042  2002              MOVS     r0,#2
000044  f88d0002          STRB     r0,[sp,#2]
;;;298    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
000048  2028              MOVS     r0,#0x28
00004a  f88d0003          STRB     r0,[sp,#3]
;;;299    	GPIO_Init(GPIOC, &GPIO_InitStructure);    
00004e  4669              MOV      r1,sp
000050  481d              LDR      r0,|L5.200|
000052  f7fffffe          BL       GPIO_Init
;;;300        	
;;;301    
;;;302    	//背光
;;;303    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000056  f44f5080          MOV      r0,#0x1000
00005a  f8ad0000          STRH     r0,[sp,#0]
;;;304    
;;;305    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00005e  2002              MOVS     r0,#2
000060  f88d0002          STRB     r0,[sp,#2]
;;;306    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
000064  2010              MOVS     r0,#0x10
000066  f88d0003          STRB     r0,[sp,#3]
;;;307    	GPIO_Init(GPIOB, &GPIO_InitStructure);    
00006a  4669              MOV      r1,sp
00006c  4815              LDR      r0,|L5.196|
00006e  f7fffffe          BL       GPIO_Init
;;;308    	GPIO_SetBits(GPIOB,GPIO_Pin_15);	
000072  f44f4100          MOV      r1,#0x8000
000076  4813              LDR      r0,|L5.196|
000078  f7fffffe          BL       GPIO_SetBits
;;;309        
;;;310    	//SW_CHECK
;;;311    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00007c  2008              MOVS     r0,#8
00007e  f8ad0000          STRH     r0,[sp,#0]
;;;312    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000082  2002              MOVS     r0,#2
000084  f88d0002          STRB     r0,[sp,#2]
;;;313    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
000088  2028              MOVS     r0,#0x28
00008a  f88d0003          STRB     r0,[sp,#3]
;;;314    	GPIO_Init(GPIOC, &GPIO_InitStructure);    
00008e  4669              MOV      r1,sp
000090  480d              LDR      r0,|L5.200|
000092  f7fffffe          BL       GPIO_Init
;;;315        	
;;;316    
;;;317    	//Beep 信号低		
;;;318    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
000096  f44f4000          MOV      r0,#0x8000
00009a  f8ad0000          STRH     r0,[sp,#0]
;;;319    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00009e  2002              MOVS     r0,#2
0000a0  f88d0002          STRB     r0,[sp,#2]
;;;320    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_OD;
0000a4  2014              MOVS     r0,#0x14
0000a6  f88d0003          STRB     r0,[sp,#3]
;;;321    	GPIO_Init(GPIOA, &GPIO_InitStructure);    
0000aa  4669              MOV      r1,sp
0000ac  4807              LDR      r0,|L5.204|
0000ae  f7fffffe          BL       GPIO_Init
;;;322           GPIO_ResetBits(GPIOA,GPIO_Pin_15);	
0000b2  f44f4100          MOV      r1,#0x8000
0000b6  4805              LDR      r0,|L5.204|
0000b8  f7fffffe          BL       GPIO_ResetBits
;;;323    
;;;324    	//两路灯打开
;;;325    #if 0
;;;326      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;327    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;328    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
;;;329    	GPIO_Init(GPIOB, &GPIO_InitStructure);    
;;;330    
;;;331    	GPIO_SetBits(GPIOB,GPIO_Pin_3);	
;;;332    
;;;333    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
;;;334    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;335    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
;;;336    	GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;337    
;;;338    	
;;;339    	GPIO_SetBits(GPIOB,GPIO_Pin_4);	
;;;340    #endif
;;;341    }
0000bc  bd08              POP      {r3,pc}
;;;342    
                          ENDP

0000be  0000              DCW      0x0000
                  |L5.192|
                          DCD      0x00300200
                  |L5.196|
                          DCD      0x40010c00
                  |L5.200|
                          DCD      0x40011000
                  |L5.204|
                          DCD      0x40010800

                          AREA ||i.Led_RW_OFF||, CODE, READONLY, ALIGN=2

                  Led_RW_OFF PROC
;;;411    *******************************************************************************/
;;;412    void Led_RW_OFF(void)
000000  b510              PUSH     {r4,lr}
;;;413    {
;;;414      //STM_EVAL_LEDOff(LED3);
;;;415      	GPIO_ResetBits(GPIOB,GPIO_Pin_3);	
000002  2108              MOVS     r1,#8
000004  4801              LDR      r0,|L6.12|
000006  f7fffffe          BL       GPIO_ResetBits
;;;416    }
00000a  bd10              POP      {r4,pc}
;;;417    /*******************************************************************************
                          ENDP

                  |L6.12|
                          DCD      0x40010c00

                          AREA ||i.Led_RW_ON||, CODE, READONLY, ALIGN=2

                  Led_RW_ON PROC
;;;398    *******************************************************************************/
;;;399    void Led_RW_ON(void)
000000  b510              PUSH     {r4,lr}
;;;400    {
;;;401      //STM_EVAL_LEDOn(LED3);
;;;402      	GPIO_SetBits(GPIOB,GPIO_Pin_3);	
000002  2108              MOVS     r1,#8
000004  4801              LDR      r0,|L7.12|
000006  f7fffffe          BL       GPIO_SetBits
;;;403    }
00000a  bd10              POP      {r4,pc}
;;;404    
                          ENDP

                  |L7.12|
                          DCD      0x40010c00

                          AREA ||i.MAL_Config||, CODE, READONLY, ALIGN=1

                  MAL_Config PROC
;;;552    *******************************************************************************/
;;;553    void MAL_Config(void)
000000  4770              BX       lr
;;;554    {
;;;555    
;;;556    //  MAL_Init(0);
;;;557    
;;;558    }
;;;559    
                          ENDP


                          AREA ||i.PWR_Check||, CODE, READONLY, ALIGN=2

                  PWR_Check PROC
;;;366    }
;;;367    void PWR_Check()
000000  b510              PUSH     {r4,lr}
;;;368    {
;;;369    	unsigned char i=0;
000002  2400              MOVS     r4,#0
;;;370    
;;;371    	while(1)
000004  e010              B        |L9.40|
                  |L9.6|
;;;372    	{
;;;373    		if(PWR_Ctrl_Check())	
000006  2108              MOVS     r1,#8
000008  4809              LDR      r0,|L9.48|
00000a  f7fffffe          BL       GPIO_ReadInputDataBit
00000e  b150              CBZ      r0,|L9.38|
;;;374    		{
;;;375    			i++;
000010  1c60              ADDS     r0,r4,#1
000012  b2c4              UXTB     r4,r0
;;;376    			Delay_ms(200);
000014  20c8              MOVS     r0,#0xc8
000016  f7fffffe          BL       Delay_ms
;;;377    
;;;378    			if(i==5)
00001a  2c05              CMP      r4,#5
00001c  d104              BNE      |L9.40|
;;;379    			{
;;;380    				Power_OFF(1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       Power_OFF
;;;381    				break;
000024  e001              B        |L9.42|
                  |L9.38|
;;;382    			}
;;;383    		}
;;;384    		else
;;;385    		{
;;;386    			break;
000026  e000              B        |L9.42|
                  |L9.40|
000028  e7ed              B        |L9.6|
                  |L9.42|
00002a  bf00              NOP                            ;381
;;;387    			i=0;
;;;388    		}
;;;389    	}
;;;390    }
00002c  bd10              POP      {r4,pc}
;;;391    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      0x40011000

                          AREA ||i.PWR_Cmd||, CODE, READONLY, ALIGN=2

                  PWR_Cmd PROC
;;;342    
;;;343    void PWR_Cmd(POWERSTATE NewState)
000000  b510              PUSH     {r4,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345    	  if(NewState != PowerOFF)
000004  b12c              CBZ      r4,|L10.18|
;;;346    	  {
;;;347    		GPIO_SetBits(GPIOB, GPIO_Pin_15);
000006  f44f4100          MOV      r1,#0x8000
00000a  4807              LDR      r0,|L10.40|
00000c  f7fffffe          BL       GPIO_SetBits
000010  e009              B        |L10.38|
                  |L10.18|
;;;348    	  }
;;;349    	  else
;;;350    	  {
;;;351    	  	GPIO_SetBits(GPIOB, GPIO_Pin_12);
000012  f44f5180          MOV      r1,#0x1000
000016  4804              LDR      r0,|L10.40|
000018  f7fffffe          BL       GPIO_SetBits
;;;352    		GPIO_ResetBits(GPIOB, GPIO_Pin_15); 
00001c  f44f4100          MOV      r1,#0x8000
000020  4801              LDR      r0,|L10.40|
000022  f7fffffe          BL       GPIO_ResetBits
                  |L10.38|
;;;353    		
;;;354    	  }
;;;355    	
;;;356    }
000026  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  |L10.40|
                          DCD      0x40010c00

                          AREA ||i.Power_OFF||, CODE, READONLY, ALIGN=2

                  Power_OFF PROC
;;;357    
;;;358    void Power_OFF(unsigned char flag)
000000  b510              PUSH     {r4,lr}
;;;359    {
000002  4604              MOV      r4,r0
;;;360    	PWR_Cmd(PowerOFF);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       PWR_Cmd
;;;361    	
;;;362    	if(flag)
00000a  b134              CBZ      r4,|L11.26|
;;;363    		while(PWR_Ctrl_Check());//检测松手
00000c  bf00              NOP      
                  |L11.14|
00000e  2108              MOVS     r1,#8
000010  4802              LDR      r0,|L11.28|
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L11.14|
                  |L11.26|
;;;364    	
;;;365    
;;;366    }
00001a  bd10              POP      {r4,pc}
;;;367    void PWR_Check()
                          ENDP

                  |L11.28|
                          DCD      0x40011000

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=1

                  Set_System PROC
;;;63     *******************************************************************************/
;;;64     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66     #if defined (STM32F37X) || defined (STM32F30X)
;;;67       GPIO_InitTypeDef  GPIO_InitStructure;
;;;68     #endif /*STM32L1XX_XD */
;;;69       
;;;70     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;71       GPIO_InitTypeDef  GPIO_InitStructure;
;;;72     #endif /* USB_USE_EXTERNAL_PULLUP */
;;;73       
;;;74       /*!< At this stage the microcontroller clock setting is already configured, 
;;;75            this is done through SystemInit() function which is called from startup
;;;76            file (startup_stm32xxx.s) before to branch to application main.
;;;77            To reconfigure the default setting of SystemInit() function, refer to
;;;78            system_stm32xxx.c file
;;;79          */ 
;;;80     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;81       /* Enable the SYSCFG module clock */
;;;82       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;83     #endif /* STM32L1XX_XD */ 
;;;84       
;;;85     #if !defined (USE_STM32L152_EVAL) 
;;;86       /* Enable and Disconnect Line GPIO clock */
;;;87       USB_Disconnect_Config();
000002  f7fffffe          BL       USB_Disconnect_Config
;;;88     #endif /* USE_STM32L152_EVAL */
;;;89     
;;;90     #if defined (STM32F37X) || defined(STM32F30X)
;;;91     
;;;92     	/* Enable the USB disconnect GPIO clock */
;;;93       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;94     
;;;95      /*Set PA11,12 as IN - USB_DM,DP*/
;;;96       
;;;97       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;98       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;99       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;100      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;101      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;102      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;103      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;104        
;;;105      /*SET PA11,12 for USB: USB_DM,DP*/
;;;106      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;107      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;108     
;;;109      /* USB_DISCONNECT used as USB pull-up */
;;;110      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;111      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;112      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;113      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;114      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;115      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure); 
;;;116    #endif /* STM32F37X && STM32F30X */   
;;;117    
;;;118    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;119      /* Enable the USB disconnect GPIO clock */
;;;120      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;121    
;;;122      /* USB_DISCONNECT used as USB pull-up */
;;;123      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;124      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;125      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;126      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;127      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;128      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;129    #endif /* USB_USE_EXTERNAL_PULLUP */  
;;;130     #if 0 
;;;131          /* Configure the EXTI line 18 connected internally to the USB IP */
;;;132      EXTI_ClearITPendingBit(EXTI_Line18);
;;;133      EXTI_InitStructure.EXTI_Line = EXTI_Line18;
;;;134      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
;;;135      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;136      EXTI_Init(&EXTI_InitStructure);
;;;137     #endif 
;;;138      /* MAL configuration */
;;;139      //MAL_Config();
;;;140    }
000006  bd10              POP      {r4,pc}
;;;141    
                          ENDP


                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;147    *******************************************************************************/
;;;148    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;151      /* Enable USB clock */
;;;152      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;153      
;;;154    #else
;;;155      /* Select USBCLK source */
;;;156      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;157      
;;;158      /* Enable the USB clock */
;;;159      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;160    #endif /* STM32L1XX_XD */
;;;161    }
000010  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;448    *******************************************************************************/
;;;449    void USB_Cable_Config (FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;450    {
000002  4604              MOV      r4,r0
;;;451    
;;;452    #if defined(STM32L1XX_MD)
;;;453      if (NewState != DISABLE)
;;;454      {
;;;455        STM32L15_USB_CONNECT;
;;;456      }
;;;457      else
;;;458      {
;;;459        STM32L15_USB_DISCONNECT;
;;;460      }  
;;;461     
;;;462    #elif defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS)
;;;463      if (NewState != DISABLE)
;;;464      {
;;;465        //GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;466    		GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;467        SYSCFG_USBPuCmd(ENABLE);
;;;468      }
;;;469      else
;;;470      {
;;;471        //GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;472    		GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;473        SYSCFG_USBPuCmd(DISABLE);
;;;474      }
;;;475    
;;;476     #else
;;;477    
;;;478      if (NewState != DISABLE)
000004  b124              CBZ      r4,|L14.16|
;;;479      {
;;;480        //GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;481    		GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000006  2104              MOVS     r1,#4
000008  4804              LDR      r0,|L14.28|
00000a  f7fffffe          BL       GPIO_SetBits
00000e  e003              B        |L14.24|
                  |L14.16|
;;;482      
;;;483      }
;;;484      else
;;;485      {
;;;486        //GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;487    		GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000010  2104              MOVS     r1,#4
000012  4802              LDR      r0,|L14.28|
000014  f7fffffe          BL       GPIO_ResetBits
                  |L14.24|
;;;488       
;;;489      }
;;;490    #endif /* STM32L1XX_MD */
;;;491    }
000018  bd10              POP      {r4,pc}
;;;492    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40011000

                          AREA ||i.USB_Configured_LED||, CODE, READONLY, ALIGN=2

                  USB_Configured_LED PROC
;;;423    *******************************************************************************/
;;;424    void USB_Configured_LED(void)
000000  b510              PUSH     {r4,lr}
;;;425    {
;;;426      	//STM_EVAL_LEDOn(LED1);
;;;427      	GPIO_SetBits(GPIOB,GPIO_Pin_4);	
000002  2110              MOVS     r1,#0x10
000004  4801              LDR      r0,|L15.12|
000006  f7fffffe          BL       GPIO_SetBits
;;;428    }
00000a  bd10              POP      {r4,pc}
;;;429    
                          ENDP

                  |L15.12|
                          DCD      0x40010c00

                          AREA ||i.USB_Disconnect_Config||, CODE, READONLY, ALIGN=2

                  USB_Disconnect_Config PROC
;;;566    *******************************************************************************/
;;;567    void USB_Disconnect_Config(void)
000000  b508              PUSH     {r3,lr}
;;;568    {
;;;569      GPIO_InitTypeDef GPIO_InitStructure;
;;;570    #if defined (USE_STM3210B_EVAL) || defined (USE_STM3210E_EVAL)
;;;571      /* Enable USB_DISCONNECT GPIO clock */
;;;572      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;573    
;;;574      /* USB_DISCONNECT_PIN used as USB pull-up */
;;;575      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
00000a  2004              MOVS     r0,#4
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;576      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;577      //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
;;;578      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000016  2010              MOVS     r0,#0x10
000018  f88d0003          STRB     r0,[sp,#3]
;;;579    #else
;;;580    	/* Enable the USB disconnect GPIO clock */
;;;581      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;582      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ALLGPIO, ENABLE);
;;;583      
;;;584      /* USB_DISCONNECT used as USB pull-up */
;;;585      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;586      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;587      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;588      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;589      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;590    
;;;591    #endif
;;;592      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L16.40|
000020  f7fffffe          BL       GPIO_Init
;;;593    }
000024  bd08              POP      {r3,pc}
;;;594    #endif /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      0x40011000

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;204    *******************************************************************************/
;;;205    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;206    {
;;;207      NVIC_InitTypeDef NVIC_InitStructure; 
;;;208      
;;;209      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;210      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;211      
;;;212    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;213      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;214      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;215      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;216      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;217      NVIC_Init(&NVIC_InitStructure);
;;;218      
;;;219        /* Enable the USB Wake-up interrupt */
;;;220      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;221      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;222      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;223      NVIC_Init(&NVIC_InitStructure);
;;;224      
;;;225    #elif defined(STM32F37X)
;;;226      /* Enable the USB interrupt */
;;;227      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;228      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;229      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;230      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;231      NVIC_Init(&NVIC_InitStructure);
;;;232      
;;;233      /* Enable the USB Wake-up interrupt */
;;;234      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;235      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;236      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;237      NVIC_Init(&NVIC_InitStructure);
;;;238      
;;;239    #else
;;;240      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;241      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;242      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2000              MOVS     r0,#0
000018  f88d0002          STRB     r0,[sp,#2]
;;;243      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;244      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;245      
;;;246        /* Enable the USB Wake-up interrupt */
;;;247      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;248      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  2000              MOVS     r0,#0
000030  f88d0001          STRB     r0,[sp,#1]
;;;249      NVIC_Init(&NVIC_InitStructure);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       NVIC_Init
;;;250    #endif /* STM32L1XX_XD */
;;;251    
;;;252      
;;;253    #if defined(STM32F10X_HD) || defined(STM32F10X_XL) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) 
;;;254      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
00003a  2031              MOVS     r0,#0x31
00003c  f88d0000          STRB     r0,[sp,#0]
;;;255      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000040  2000              MOVS     r0,#0
000042  f88d0001          STRB     r0,[sp,#1]
;;;256      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000046  f88d0002          STRB     r0,[sp,#2]
;;;257      NVIC_Init(&NVIC_InitStructure);
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       NVIC_Init
;;;258      NVIC_InitStructure.NVIC_IRQChannel = SD_SDIO_DMA_IRQn;
000050  203b              MOVS     r0,#0x3b
000052  f88d0000          STRB     r0,[sp,#0]
;;;259      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000056  2000              MOVS     r0,#0
000058  f88d0001          STRB     r0,[sp,#1]
;;;260      NVIC_Init(&NVIC_InitStructure);
00005c  4668              MOV      r0,sp
00005e  f7fffffe          BL       NVIC_Init
;;;261    #endif /* STM32L1XX_MD */
;;;262     
;;;263    }
000062  bd08              POP      {r3,pc}
;;;264    
                          ENDP


                          AREA ||i.USB_NotConfigured_LED||, CODE, READONLY, ALIGN=2

                  USB_NotConfigured_LED PROC
;;;436    *******************************************************************************/
;;;437    void USB_NotConfigured_LED(void)
000000  b510              PUSH     {r4,lr}
;;;438    {
;;;439    	//STM_EVAL_LEDOff(LED1);
;;;440    	GPIO_ResetBits(GPIOB,GPIO_Pin_4);	
000002  2110              MOVS     r1,#0x10
000004  4801              LDR      r0,|L18.12|
000006  f7fffffe          BL       GPIO_ResetBits
;;;441    }
00000a  bd10              POP      {r4,pc}
;;;442    
                          ENDP

                  |L18.12|
                          DCD      0x40010c00

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStartUpStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 144
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
