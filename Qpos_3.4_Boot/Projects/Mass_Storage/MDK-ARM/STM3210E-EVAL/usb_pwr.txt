; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\usb_pwr.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\usb_pwr.crf ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;94     *******************************************************************************/
;;;95     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97       /* disable all interrupts and force USB reset */
;;;98       _SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]
;;;99       /* clear interrupt status register */
;;;100      _SetISTR(0);
000008  2000              MOVS     r0,#0
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;101      /* Disable the Pull-Up*/
;;;102      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;103      /* switch-off device */
;;;104      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  4901              LDR      r1,|L1.28|
000016  6008              STR      r0,[r1,#0]
;;;105      /* sw variables reset */
;;;106      /* ... */
;;;107    
;;;108      return USB_SUCCESS;
000018  2000              MOVS     r0,#0
;;;109    }
00001a  bd10              POP      {r4,pc}
;;;110    
                          ENDP

                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;64     *******************************************************************************/
;;;65     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;66     {
;;;67       uint16_t wRegVal;
;;;68     
;;;69       /*** cable plugged-in ? ***/
;;;70       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;71     
;;;72       /*** CNTR_PWDN = 0 ***/
;;;73       wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;74       _SetCNTR(wRegVal);
00000a  480b              LDR      r0,|L2.56|
00000c  6004              STR      r4,[r0,#0]
;;;75     
;;;76       /*** CNTR_FRES = 0 ***/
;;;77       wInterrupt_Mask = 0;
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L2.60|
000012  8008              STRH     r0,[r1,#0]
;;;78       _SetCNTR(wInterrupt_Mask);
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4907              LDR      r1,|L2.56|
00001a  6008              STR      r0,[r1,#0]
;;;79       /*** Clear pending interrupts ***/
;;;80       _SetISTR(0);
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;81       /*** Set interrupt mask ***/
;;;82       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4905              LDR      r1,|L2.60|
000028  8008              STRH     r0,[r1,#0]
;;;83       _SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]
;;;84       
;;;85       return USB_SUCCESS;
000032  2000              MOVS     r0,#0
;;;86     }
000034  bd10              POP      {r4,pc}
;;;87     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005c40
                  |L2.60|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;259    *******************************************************************************/
;;;260    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  4605              MOV      r5,r0
;;;262      uint16_t wCNTR;
;;;263    
;;;264      if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;265        ResumeS.eState = eResumeSetVal;
000008  482e              LDR      r0,|L3.196|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;266      switch (ResumeS.eState)
00000c  482d              LDR      r0,|L3.196|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d24e              BCS      |L3.178|
000014  e8dff000          TBB      [pc,r0]
000018  04111a20          DCB      0x04,0x11,0x1a,0x20
00001c  2b384e4f          DCB      0x2b,0x38,0x4e,0x4f
;;;267      {
;;;268        case RESUME_EXTERNAL:
;;;269          if (remotewakeupon ==0)
000020  4829              LDR      r0,|L3.200|
000022  6800              LDR      r0,[r0,#0]  ; remotewakeupon
000024  b928              CBNZ     r0,|L3.50|
;;;270          {
;;;271            Resume_Init();
000026  f7fffffe          BL       Resume_Init
;;;272            ResumeS.eState = RESUME_OFF;
00002a  2006              MOVS     r0,#6
00002c  4925              LDR      r1,|L3.196|
00002e  7008              STRB     r0,[r1,#0]
000030  e002              B        |L3.56|
                  |L3.50|
;;;273          }
;;;274          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;275          {
;;;276            ResumeS.eState = RESUME_ON;
000032  2005              MOVS     r0,#5
000034  4923              LDR      r1,|L3.196|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;277          }
;;;278          break;
000038  e041              B        |L3.190|
;;;279        case RESUME_INTERNAL:
;;;280          Resume_Init();
00003a  f7fffffe          BL       Resume_Init
;;;281          ResumeS.eState = RESUME_START;
00003e  2004              MOVS     r0,#4
000040  4920              LDR      r1,|L3.196|
000042  7008              STRB     r0,[r1,#0]
;;;282          remotewakeupon = 1;
000044  2001              MOVS     r0,#1
000046  4920              LDR      r1,|L3.200|
000048  6008              STR      r0,[r1,#0]  ; remotewakeupon
;;;283          break;
00004a  e038              B        |L3.190|
;;;284        case RESUME_LATER:
;;;285          ResumeS.bESOFcnt = 2;
00004c  2002              MOVS     r0,#2
00004e  491d              LDR      r1,|L3.196|
000050  7048              STRB     r0,[r1,#1]
;;;286          ResumeS.eState = RESUME_WAIT;
000052  2003              MOVS     r0,#3
000054  7008              STRB     r0,[r1,#0]
;;;287          break;
000056  e032              B        |L3.190|
;;;288        case RESUME_WAIT:
;;;289          ResumeS.bESOFcnt--;
000058  481a              LDR      r0,|L3.196|
00005a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00005c  1e40              SUBS     r0,r0,#1
00005e  4919              LDR      r1,|L3.196|
000060  7048              STRB     r0,[r1,#1]
;;;290          if (ResumeS.bESOFcnt == 0)
000062  4608              MOV      r0,r1
000064  7840              LDRB     r0,[r0,#1]  ; ResumeS
000066  b908              CBNZ     r0,|L3.108|
;;;291            ResumeS.eState = RESUME_START;
000068  2004              MOVS     r0,#4
00006a  7008              STRB     r0,[r1,#0]
                  |L3.108|
;;;292          break;
00006c  e027              B        |L3.190|
;;;293        case RESUME_START:
;;;294          wCNTR = _GetCNTR();
00006e  4817              LDR      r0,|L3.204|
000070  6800              LDR      r0,[r0,#0]
000072  b284              UXTH     r4,r0
;;;295          wCNTR |= CNTR_RESUME;
000074  f0440410          ORR      r4,r4,#0x10
;;;296          _SetCNTR(wCNTR);
000078  4814              LDR      r0,|L3.204|
00007a  6004              STR      r4,[r0,#0]
;;;297          ResumeS.eState = RESUME_ON;
00007c  2005              MOVS     r0,#5
00007e  4911              LDR      r1,|L3.196|
000080  7008              STRB     r0,[r1,#0]
;;;298          ResumeS.bESOFcnt = 10;
000082  200a              MOVS     r0,#0xa
000084  7048              STRB     r0,[r1,#1]
;;;299          break;
000086  e01a              B        |L3.190|
;;;300        case RESUME_ON:    
;;;301          ResumeS.bESOFcnt--;
000088  480e              LDR      r0,|L3.196|
00008a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00008c  1e40              SUBS     r0,r0,#1
00008e  490d              LDR      r1,|L3.196|
000090  7048              STRB     r0,[r1,#1]
;;;302          if (ResumeS.bESOFcnt == 0)
000092  4608              MOV      r0,r1
000094  7840              LDRB     r0,[r0,#1]  ; ResumeS
000096  b958              CBNZ     r0,|L3.176|
;;;303          {
;;;304            wCNTR = _GetCNTR();
000098  480c              LDR      r0,|L3.204|
00009a  6800              LDR      r0,[r0,#0]
00009c  b284              UXTH     r4,r0
;;;305            wCNTR &= (~CNTR_RESUME);
00009e  f0240410          BIC      r4,r4,#0x10
;;;306            _SetCNTR(wCNTR);
0000a2  480a              LDR      r0,|L3.204|
0000a4  6004              STR      r4,[r0,#0]
;;;307            ResumeS.eState = RESUME_OFF;
0000a6  2006              MOVS     r0,#6
0000a8  7008              STRB     r0,[r1,#0]
;;;308            remotewakeupon = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4906              LDR      r1,|L3.200|
0000ae  6008              STR      r0,[r1,#0]  ; remotewakeupon
                  |L3.176|
;;;309          }
;;;310          break;
0000b0  e005              B        |L3.190|
                  |L3.178|
;;;311        case RESUME_OFF:
0000b2  bf00              NOP      
;;;312        case RESUME_ESOF:
0000b4  bf00              NOP      
;;;313        default:
;;;314          ResumeS.eState = RESUME_OFF;
0000b6  2006              MOVS     r0,#6
0000b8  4902              LDR      r1,|L3.196|
0000ba  7008              STRB     r0,[r1,#0]
;;;315          break;
0000bc  bf00              NOP      
                  |L3.190|
0000be  bf00              NOP                            ;278
;;;316      }
;;;317    }
0000c0  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ResumeS
                  |L3.200|
                          DCD      remotewakeupon
                  |L3.204|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;222    *******************************************************************************/
;;;223    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;224    {
;;;225      uint16_t wCNTR;
;;;226      
;;;227      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;228      /* restart the clocks */
;;;229      /* ...  */
;;;230    
;;;231      /* CNTR_LPMODE = 0 */
;;;232      wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;233      wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;234      _SetCNTR(wCNTR);    
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;235      
;;;236      /* restore full power */
;;;237      /* ... on connected devices */
;;;238      Leave_LowPowerMode();
000010  f7fffffe          BL       Leave_LowPowerMode
;;;239    
;;;240      /* reset FSUSP bit */
;;;241      _SetCNTR(IMR_MSK);
000014  f44f403f          MOV      r0,#0xbf00
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;242    
;;;243      /* reverse suspend preparation */
;;;244      /* ... */ 
;;;245    
;;;246    }
00001c  bd10              POP      {r4,pc}
;;;247    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;117    *******************************************************************************/
;;;118    void Suspend(void)
000000  b538              PUSH     {r3-r5,lr}
;;;119    {
;;;120    	uint32_t i =0;
000002  2100              MOVS     r1,#0
;;;121    	uint16_t wCNTR;
;;;122    	uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;123      __IO uint32_t savePWR_CR=0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;124    	/* suspend preparation */
;;;125    	/* ... */
;;;126    	
;;;127    	/*Store CNTR value */
;;;128    	wCNTR = _GetCNTR();  
00000a  4b39              LDR      r3,|L5.240|
00000c  681b              LDR      r3,[r3,#0]
00000e  b298              UXTH     r0,r3
;;;129    
;;;130        /* This a sequence to apply a force RESET to handle a robustness case */
;;;131        
;;;132    	/*Store endpoints registers status */
;;;133        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
000010  bf00              NOP      
000012  e009              B        |L5.40|
                  |L5.20|
000014  4c37              LDR      r4,|L5.244|
000016  eb040381          ADD      r3,r4,r1,LSL #2
00001a  f8d33c00          LDR      r3,[r3,#0xc00]
00001e  b29b              UXTH     r3,r3
000020  4c35              LDR      r4,|L5.248|
000022  f8443021          STR      r3,[r4,r1,LSL #2]
000026  1c49              ADDS     r1,r1,#1
                  |L5.40|
000028  2908              CMP      r1,#8
00002a  d3f3              BCC      |L5.20|
;;;134    	
;;;135    	/* unmask RESET flag */
;;;136    	wCNTR|=CNTR_RESETM;
00002c  f4406080          ORR      r0,r0,#0x400
;;;137    	_SetCNTR(wCNTR);
000030  4b2f              LDR      r3,|L5.240|
000032  6018              STR      r0,[r3,#0]
;;;138    	
;;;139    	/*apply FRES */
;;;140    	wCNTR|=CNTR_FRES;
000034  f0400001          ORR      r0,r0,#1
;;;141    	_SetCNTR(wCNTR);
000038  6018              STR      r0,[r3,#0]
;;;142    	
;;;143    	/*clear FRES*/
;;;144    	wCNTR&=~CNTR_FRES;
00003a  f0200001          BIC      r0,r0,#1
;;;145    	_SetCNTR(wCNTR);
00003e  6018              STR      r0,[r3,#0]
;;;146    	
;;;147    	/*poll for RESET flag in ISTR*/
;;;148    	while((_GetISTR()&ISTR_RESET) == 0);
000040  bf00              NOP      
                  |L5.66|
000042  4b2b              LDR      r3,|L5.240|
000044  1d1b              ADDS     r3,r3,#4
000046  681b              LDR      r3,[r3,#0]
000048  f4036380          AND      r3,r3,#0x400
00004c  2b00              CMP      r3,#0
00004e  d0f8              BEQ      |L5.66|
;;;149    	
;;;150    	/* clear RESET flag in ISTR */
;;;151    	_SetISTR((uint16_t)CLR_RESET);
000050  f64f33ff          MOV      r3,#0xfbff
000054  4c26              LDR      r4,|L5.240|
000056  1d24              ADDS     r4,r4,#4
000058  6023              STR      r3,[r4,#0]
;;;152    	
;;;153    	/*restore Enpoints*/
;;;154    	for (i=0;i<8;i++)
00005a  2100              MOVS     r1,#0
00005c  e009              B        |L5.114|
                  |L5.94|
;;;155    	_SetENDPOINT(i, EP[i]);
00005e  4b26              LDR      r3,|L5.248|
000060  f8533021          LDR      r3,[r3,r1,LSL #2]
000064  b29b              UXTH     r3,r3
000066  4d23              LDR      r5,|L5.244|
000068  eb050481          ADD      r4,r5,r1,LSL #2
00006c  f8c43c00          STR      r3,[r4,#0xc00]
000070  1c49              ADDS     r1,r1,#1              ;154
                  |L5.114|
000072  2908              CMP      r1,#8                 ;154
000074  d3f3              BCC      |L5.94|
;;;156    	
;;;157    	/* Now it is safe to enter macrocell in suspend mode */
;;;158    	wCNTR |= CNTR_FSUSP;
000076  f0400008          ORR      r0,r0,#8
;;;159    	_SetCNTR(wCNTR);
00007a  4b1d              LDR      r3,|L5.240|
00007c  6018              STR      r0,[r3,#0]
;;;160    	
;;;161    	/* force low-power mode in the macrocell */
;;;162    	wCNTR = _GetCNTR();
00007e  681b              LDR      r3,[r3,#0]
000080  b298              UXTH     r0,r3
;;;163    	wCNTR |= CNTR_LPMODE;
000082  f0400004          ORR      r0,r0,#4
;;;164    	_SetCNTR(wCNTR);
000086  4b1a              LDR      r3,|L5.240|
000088  6018              STR      r0,[r3,#0]
;;;165    	
;;;166    	/*prepare entry in low power mode (STOP mode)*/
;;;167    	/* Select the regulator state in STOP mode*/
;;;168    	savePWR_CR = PWR->CR;
00008a  4b1c              LDR      r3,|L5.252|
00008c  681b              LDR      r3,[r3,#0]
00008e  9300              STR      r3,[sp,#0]
;;;169    	tmpreg = PWR->CR;
000090  4b1a              LDR      r3,|L5.252|
000092  681a              LDR      r2,[r3,#0]
;;;170    	/* Clear PDDS and LPDS bits */
;;;171    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000094  f0220203          BIC      r2,r2,#3
;;;172    	/* Set LPDS bit according to PWR_Regulator value */
;;;173    	tmpreg |= PWR_Regulator_LowPower;
000098  f0420201          ORR      r2,r2,#1
;;;174    	/* Store the new value */
;;;175    	PWR->CR = tmpreg;
00009c  601a              STR      r2,[r3,#0]
;;;176    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;177    #if defined (STM32F30X) || defined (STM32F37X)
;;;178            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;179    #else
;;;180            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
00009e  4b18              LDR      r3,|L5.256|
0000a0  681b              LDR      r3,[r3,#0]
0000a2  f0430304          ORR      r3,r3,#4
0000a6  4c16              LDR      r4,|L5.256|
0000a8  6023              STR      r3,[r4,#0]
;;;181    #endif
;;;182    	
;;;183    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;184    	if((_GetISTR()&ISTR_WKUP)==0)
0000aa  4b11              LDR      r3,|L5.240|
0000ac  1d1b              ADDS     r3,r3,#4
0000ae  681b              LDR      r3,[r3,#0]
0000b0  f4035380          AND      r3,r3,#0x1000
0000b4  b933              CBNZ     r3,|L5.196|
;;;185    	{
;;;186    		__WFI();
0000b6  bf30              WFI      
;;;187    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;188    #if defined (STM32F30X) || defined (STM32F37X)
;;;189                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;190    #else
;;;191                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
0000b8  4623              MOV      r3,r4
0000ba  681b              LDR      r3,[r3,#0]
0000bc  f0230304          BIC      r3,r3,#4
0000c0  6023              STR      r3,[r4,#0]
0000c2  e014              B        |L5.238|
                  |L5.196|
;;;192    #endif
;;;193    	}
;;;194    	else
;;;195    	{
;;;196    		/* Clear Wakeup flag */
;;;197    		_SetISTR(CLR_WKUP);
0000c4  f64e73ff          MOV      r3,#0xefff
0000c8  4c09              LDR      r4,|L5.240|
0000ca  1d24              ADDS     r4,r4,#4
0000cc  6023              STR      r3,[r4,#0]
;;;198    		/* clear FSUSP to abort entry in suspend mode  */
;;;199                    wCNTR = _GetCNTR();
0000ce  1f23              SUBS     r3,r4,#4
0000d0  681b              LDR      r3,[r3,#0]
0000d2  b298              UXTH     r0,r3
;;;200                    wCNTR&=~CNTR_FSUSP;
0000d4  f0200008          BIC      r0,r0,#8
;;;201                    _SetCNTR(wCNTR);
0000d8  1f23              SUBS     r3,r4,#4
0000da  6018              STR      r0,[r3,#0]
;;;202    		
;;;203    		/*restore sleep mode configuration */ 
;;;204    		/* restore Power regulator config in sleep mode*/
;;;205    		PWR->CR = savePWR_CR;
0000dc  4c07              LDR      r4,|L5.252|
0000de  9b00              LDR      r3,[sp,#0]
0000e0  6023              STR      r3,[r4,#0]
;;;206    		
;;;207    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;208    #if defined (STM32F30X) || defined (STM32F37X)		
;;;209                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;210    #else
;;;211                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
0000e2  4b07              LDR      r3,|L5.256|
0000e4  681b              LDR      r3,[r3,#0]
0000e6  f0230304          BIC      r3,r3,#4
0000ea  4c05              LDR      r4,|L5.256|
0000ec  6023              STR      r3,[r4,#0]
                  |L5.238|
;;;212    #endif
;;;213        }
;;;214    }
0000ee  bd38              POP      {r3-r5,pc}
;;;215    
                          ENDP

                  |L5.240|
                          DCD      0x40005c40
                  |L5.244|
                          DCD      0x40005000
                  |L5.248|
                          DCD      ||EP||
                  |L5.252|
                          DCD      0x40007000
                  |L5.256|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  00                DCB      0x00
                  ResumeS
000005  000000            DCB      0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 144
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
