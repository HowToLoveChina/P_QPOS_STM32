; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\app_boot.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\app_boot.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\app_boot.crf ..\src\app_boot.c]
                          THUMB

                          AREA ||i.BOOT_NVMEM_Erase||, CODE, READONLY, ALIGN=2

                  BOOT_NVMEM_Erase PROC
;;;83     //从指定地址连续擦除片内Flash若干页
;;;84     void BOOT_NVMEM_Erase(unsigned int baseAddr,unsigned int startAddr, unsigned int len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;85     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;86     	unsigned int i;
;;;87     	unsigned int uiFlashAddr;
;;;88     	unsigned int uiEraseAddr;
;;;89     
;;;90     	uiFlashAddr = baseAddr | startAddr;
00000a  ea460807          ORR      r8,r6,r7
;;;91     
;;;92     	uiEraseAddr = uiFlashAddr & FLASH_PAGE_ADDR_HI;
00000e  480d              LDR      r0,|L1.68|
000010  ea080900          AND      r9,r8,r0
;;;93     	uiEraseAddr |= FLASH_START_ADDR;
000014  f0496900          ORR      r9,r9,#0x8000000
;;;94     		
;;;95     	if((len & (FLASH_PAGE_SIZE - 1)) != 0)
000018  f3c4000a          UBFX     r0,r4,#0,#11
00001c  b118              CBZ      r0,|L1.38|
;;;96     	{
;;;97     		len = (len+FLASH_PAGE_SIZE)/FLASH_PAGE_SIZE*FLASH_PAGE_SIZE ; 
00001e  f5046000          ADD      r0,r4,#0x800
000022  0ac0              LSRS     r0,r0,#11
000024  02c4              LSLS     r4,r0,#11
                  |L1.38|
;;;98     	}
;;;99     
;;;100    	for(i = 0; i < (len / FLASH_PAGE_SIZE); i++)
000026  2500              MOVS     r5,#0
000028  e006              B        |L1.56|
                  |L1.42|
;;;101    	{
;;;102    		FLASH_If_Erase(uiFlashAddr + FLASH_PAGE_SIZE * i);	
00002a  f44f6100          MOV      r1,#0x800
00002e  fb018005          MLA      r0,r1,r5,r8
000032  f7fffffe          BL       FLASH_If_Erase
000036  1c6d              ADDS     r5,r5,#1              ;100
                  |L1.56|
000038  ebb52fd4          CMP      r5,r4,LSR #11         ;100
00003c  d3f5              BCC      |L1.42|
;;;103    	}
;;;104    
;;;105    	return;
;;;106    }
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;107    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x0003f801

                          AREA ||i.BOOT_NVMEM_Read||, CODE, READONLY, ALIGN=1

                  BOOT_NVMEM_Read PROC
;;;11     //从指定地址处连续读取片内Flash若干字节数据
;;;12     void BOOT_NVMEM_Read(unsigned int startAddr, unsigned char* puchDataBuff, unsigned int len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;13     {
000002  4603              MOV      r3,r0
;;;14     	unsigned int uiCount = 0;
000004  2400              MOVS     r4,#0
;;;15     	unsigned int uiAddr;
;;;16     	if(puchDataBuff == 0)
000006  b901              CBNZ     r1,|L2.10|
                  |L2.8|
;;;17     	{
;;;18     		return;
;;;19     	}
;;;20     	
;;;21     	uiAddr = (startAddr & FLASH_ADDR_MASK)|FLASH_START_ADDR;
;;;22     	while(uiCount < len) 
;;;23     	{
;;;24     		puchDataBuff[uiCount++]= *(__IO uint8_t*)(uiAddr++);
;;;25     	}
;;;26     
;;;27     }
000008  bdf0              POP      {r4-r7,pc}
                  |L2.10|
00000a  f3c30511          UBFX     r5,r3,#0,#18          ;21
00000e  f0456000          ORR      r0,r5,#0x8000000      ;21
000012  e004              B        |L2.30|
                  |L2.20|
000014  f8107b01          LDRB     r7,[r0],#1            ;24
000018  4625              MOV      r5,r4                 ;24
00001a  1c64              ADDS     r4,r4,#1              ;24
00001c  554f              STRB     r7,[r1,r5]            ;24
                  |L2.30|
00001e  4294              CMP      r4,r2                 ;22
000020  d3f8              BCC      |L2.20|
000022  bf00              NOP      
000024  e7f0              B        |L2.8|
;;;28     
                          ENDP


                          AREA ||i.BOOT_NVMEM_Write||, CODE, READONLY, ALIGN=2

                  BOOT_NVMEM_Write PROC
;;;29     //向指定地址处连续写入片内Flash若干字节数据，无掉电保护
;;;30     void BOOT_NVMEM_Write(unsigned int uiFlashAddr, unsigned char* pucDataBuff, unsigned int uiLen)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;31     {  
000004  4607              MOV      r7,r0
000006  4615              MOV      r5,r2
;;;32     	unsigned int uiOffset, uiAddr;
;;;33     	unsigned int uiFlashPageAddr;
;;;34     	unsigned int uiLength, uiCopyLen;
;;;35     
;;;36     	unsigned char *pucTemp;
;;;37     
;;;38     	if(uiFlashAddr + uiLen > FLASH_END_ADDR)
000008  1978              ADDS     r0,r7,r5
00000a  4920              LDR      r1,|L3.140|
00000c  4288              CMP      r0,r1
00000e  d901              BLS      |L3.20|
                  |L3.16|
;;;39     		return ;
;;;40     
;;;41     	uiAddr = (uiFlashAddr & FLASH_ADDR_MASK);  			//flash绝对地址
;;;42     	uiFlashPageAddr = uiAddr  & FLASH_PAGE_ADDR_HI;   //获取目的地址所在扇区的起始地址
;;;43     	uiFlashPageAddr |= FLASH_START_ADDR;
;;;44     	uiOffset = uiAddr  & FLASH_PAGE_ADDR_LO;			//获取目的地址在扇区中的偏移量
;;;45     	uiCopyLen= FLASH_PAGE_SIZE - uiOffset ;				//计算需要从输入缓冲中copy过来的数据块大小
;;;46     
;;;47     	if(uiCopyLen > uiLen)
;;;48     	{
;;;49     	uiCopyLen = uiLen;
;;;50     	}
;;;51     	else{}
;;;52     
;;;53     	uiLength = uiLen;
;;;54     	pucTemp = pucDataBuff;
;;;55     
;;;56     	do
;;;57     	{        
;;;58     		if(uiCopyLen < FLASH_PAGE_SIZE)
;;;59     		{
;;;60     			BOOT_NVMEM_Read(uiFlashPageAddr, MAL_Buffer, FLASH_PAGE_SIZE);
;;;61     		}
;;;62     			
;;;63     		memcpy(MAL_Buffer + uiOffset, pucTemp, uiCopyLen);	//更新缓冲区中的扇区内容        
;;;64     		FLASH_If_Erase(uiFlashPageAddr);   	//擦除整个扇区 
;;;65     		FLASH_If_Write(uiFlashPageAddr, FLASH_PAGE_SIZE);			       
;;;66     		uiFlashPageAddr += FLASH_PAGE_SIZE;
;;;67     		uiOffset = 0;
;;;68     		uiLength -= uiCopyLen;
;;;69     		pucTemp += uiCopyLen;
;;;70     
;;;71     		if(uiLength > FLASH_PAGE_SIZE)
;;;72     		{
;;;73     			uiCopyLen = FLASH_PAGE_SIZE;
;;;74     		}
;;;75     		else
;;;76     		{
;;;77     			uiCopyLen = uiLength;
;;;78     		}
;;;79     	}while( uiLength > 0);
;;;80     
;;;81     }
000010  e8bd8ffe          POP      {r1-r11,pc}
                  |L3.20|
000014  f3c70911          UBFX     r9,r7,#0,#18          ;41
000018  481d              LDR      r0,|L3.144|
00001a  ea090a00          AND      r10,r9,r0             ;42
00001e  f04a6a00          ORR      r10,r10,#0x8000000    ;43
000022  f3c9080a          UBFX     r8,r9,#0,#11          ;44
000026  f5c86400          RSB      r4,r8,#0x800          ;45
00002a  42ac              CMP      r4,r5                 ;47
00002c  d900              BLS      |L3.48|
00002e  462c              MOV      r4,r5                 ;49
                  |L3.48|
000030  462e              MOV      r6,r5                 ;53
000032  f8ddb004          LDR      r11,[sp,#4]           ;54
000036  bf00              NOP                            ;56
                  |L3.56|
000038  f5b46f00          CMP      r4,#0x800             ;58
00003c  d205              BCS      |L3.74|
00003e  f44f6200          MOV      r2,#0x800             ;60
000042  4914              LDR      r1,|L3.148|
000044  4650              MOV      r0,r10                ;60
000046  f7fffffe          BL       BOOT_NVMEM_Read
                  |L3.74|
00004a  4912              LDR      r1,|L3.148|
00004c  eb010008          ADD      r0,r1,r8              ;63
000050  4622              MOV      r2,r4                 ;63
000052  4659              MOV      r1,r11                ;63
000054  f7fffffe          BL       __aeabi_memcpy
000058  4650              MOV      r0,r10                ;64
00005a  f7fffffe          BL       FLASH_If_Erase
00005e  f44f6100          MOV      r1,#0x800             ;65
000062  4650              MOV      r0,r10                ;65
000064  f7fffffe          BL       FLASH_If_Write
000068  f50a6a00          ADD      r10,r10,#0x800        ;66
00006c  f04f0800          MOV      r8,#0                 ;67
000070  1b36              SUBS     r6,r6,r4              ;68
000072  44a3              ADD      r11,r11,r4            ;69
000074  f5b66f00          CMP      r6,#0x800             ;71
000078  d902              BLS      |L3.128|
00007a  f44f6400          MOV      r4,#0x800             ;73
00007e  e000              B        |L3.130|
                  |L3.128|
000080  4634              MOV      r4,r6                 ;77
                  |L3.130|
000082  2e00              CMP      r6,#0                 ;79
000084  d1d8              BNE      |L3.56|
000086  bf00              NOP      
000088  e7c2              B        |L3.16|
;;;82     
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      0x0803ffff
                  |L3.144|
                          DCD      0x0003f801
                  |L3.148|
                          DCD      MAL_Buffer

                          AREA ||i.Boot_Command||, CODE, READONLY, ALIGN=2

                  Boot_Command PROC
;;;318    
;;;319    void Boot_Command(void)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
;;;321    	unsigned int ret;
;;;322    
;;;323    	if(G_APDU.CLA != 0x7B)
000002  4845              LDR      r0,|L4.280|
000004  7800              LDRB     r0,[r0,#0]  ; G_APDU
000006  287b              CMP      r0,#0x7b
000008  d007              BEQ      |L4.26|
;;;324    	{
;;;325    		G_APDU.RLE = 0;
00000a  2000              MOVS     r0,#0
00000c  4942              LDR      r1,|L4.280|
00000e  6088              STR      r0,[r1,#8]  ; G_APDU
;;;326    		G_APDU.SW1 = 0x6d;
000010  206d              MOVS     r0,#0x6d
000012  7308              STRB     r0,[r1,#0xc]
;;;327    		G_APDU.SW2 = 0x00;
000014  2000              MOVS     r0,#0
000016  7348              STRB     r0,[r1,#0xd]
                  |L4.24|
;;;328    		return;
;;;329    	}
;;;330    
;;;331    	switch(G_APDU.INS)
;;;332    	{	
;;;333    	case CMD_BOOT_VERSION:
;;;334    		memcpy(G_APDU.pOutData, BOOT_VERSION, strlen(BOOT_VERSION));
;;;335    		G_APDU.RLE = strlen(BOOT_VERSION);
;;;336    		G_APDU.SW1 = 0x90;
;;;337    		G_APDU.SW2 = 0x00;
;;;338    		break;
;;;339    	case CMD_BOOT_DNLOAD_KEY: //下载或读取密钥	
;;;340    		ret = CMD_BOOT_Write_Key();
;;;341    		if(ret != SW_OPERATION_SUCCESS)
;;;342    			G_APDU.RLE = 0;	
;;;343    		G_APDU.SW1 = ret>>8;
;;;344    		G_APDU.SW2 = ret&0x00ff;
;;;345    		break;	
;;;346    	case CMD_DNLOAD_DATA_DES:
;;;347    		ret = CMD_BOOT_DNLOAD_DATA_DES3();
;;;348    		if(ret != SW_OPERATION_SUCCESS)
;;;349    			G_APDU.RLE = 0;	
;;;350    		G_APDU.SW1 = ret>>8;
;;;351    		G_APDU.SW2 = ret&0x00ff;
;;;352    		break;
;;;353    #if BOOT_TEST
;;;354    	case 0xEF:
;;;355    		ret =  CMD_BOOT_Test();
;;;356    		if(ret != SW_OPERATION_SUCCESS)
;;;357    			G_APDU.RLE = 0;	
;;;358    		G_APDU.SW1 = ret>>8;
;;;359    		G_APDU.SW2 = ret&0x00ff;
;;;360    		break;
;;;361    #endif
;;;362    	case CMD_BOOT_CRC:
;;;363    		ret = CMD_BOOT_CRC_DATA();
;;;364    		if(ret != SW_OPERATION_SUCCESS)
;;;365    			G_APDU.RLE = 0;	
;;;366    		G_APDU.SW1 = ret>>8;
;;;367    		G_APDU.SW2 = ret&0x00ff;
;;;368    		break;
;;;369    	case CMD_SPIFLASH_GETID:
;;;370    		ret = CMD_BOOT_GetID_SPIFlash();
;;;371    		if(ret != SW_OPERATION_SUCCESS)
;;;372    			G_APDU.RLE = 0;	
;;;373    		G_APDU.SW1 = ret>>8;
;;;374    		G_APDU.SW2 = ret&0x00ff;
;;;375    		break;
;;;376    	case CMD_SPIFLASH_READ:
;;;377    		ret = CMD_BOOT_Read_SPIFlash();
;;;378    		if(ret != SW_OPERATION_SUCCESS)
;;;379    			G_APDU.RLE = 0;	
;;;380    		G_APDU.SW1 = ret>>8;
;;;381    		G_APDU.SW2 = ret&0x00ff;
;;;382    		break;
;;;383    	case CMD_SPIFLASH_WRITE:
;;;384    		ret = CMD_BOOT_Write_SPIFlash();
;;;385    		if(ret != SW_OPERATION_SUCCESS)
;;;386    			G_APDU.RLE = 0;	
;;;387    		G_APDU.SW1 = ret>>8;
;;;388    		G_APDU.SW2 = ret&0x00ff;
;;;389    		break;
;;;390    	default:
;;;391    		G_APDU.RLE = 0;
;;;392    		ret = 0x6D00;
;;;393    		break;
;;;394    	}
;;;395    	
;;;396    	G_APDU.SW1 = ret>>8;
;;;397    	G_APDU.SW2 = ret&0x00ff;
;;;398    
;;;399    }
000018  bd70              POP      {r4-r6,pc}
                  |L4.26|
00001a  483f              LDR      r0,|L4.280|
00001c  7840              LDRB     r0,[r0,#1]            ;331  ; G_APDU
00001e  2807              CMP      r0,#7                 ;331
000020  d26d              BCS      |L4.254|
000022  e8dff000          TBB      [pc,r0]               ;331
000026  0418              DCB      0x04,0x18
000028  26344250          DCB      0x26,0x34,0x42,0x50
00002c  5e00              DCB      0x5e,0x00
00002e  a03b              ADR      r0,|L4.284|
000030  f7fffffe          BL       strlen
000034  4605              MOV      r5,r0                 ;334
000036  4938              LDR      r1,|L4.280|
000038  462a              MOV      r2,r5                 ;334
00003a  6948              LDR      r0,[r1,#0x14]         ;334  ; G_APDU
00003c  a137              ADR      r1,|L4.284|
00003e  f7fffffe          BL       __aeabi_memcpy
000042  a036              ADR      r0,|L4.284|
000044  f7fffffe          BL       strlen
000048  4933              LDR      r1,|L4.280|
00004a  6088              STR      r0,[r1,#8]            ;335  ; G_APDU
00004c  2090              MOVS     r0,#0x90              ;336
00004e  7308              STRB     r0,[r1,#0xc]          ;336
000050  2000              MOVS     r0,#0                 ;337
000052  7348              STRB     r0,[r1,#0xd]          ;337
000054  e059              B        |L4.266|
000056  f7fffffe          BL       CMD_BOOT_Write_Key
00005a  4604              MOV      r4,r0                 ;340
00005c  f5b44f10          CMP      r4,#0x9000            ;341
000060  d002              BEQ      |L4.104|
000062  2000              MOVS     r0,#0                 ;342
000064  492c              LDR      r1,|L4.280|
000066  6088              STR      r0,[r1,#8]            ;342  ; G_APDU
                  |L4.104|
000068  0a20              LSRS     r0,r4,#8              ;343
00006a  492b              LDR      r1,|L4.280|
00006c  7308              STRB     r0,[r1,#0xc]          ;343
00006e  734c              STRB     r4,[r1,#0xd]          ;344
000070  e04b              B        |L4.266|
000072  f7fffffe          BL       CMD_BOOT_DNLOAD_DATA_DES3
000076  4604              MOV      r4,r0                 ;347
000078  f5b44f10          CMP      r4,#0x9000            ;348
00007c  d002              BEQ      |L4.132|
00007e  2000              MOVS     r0,#0                 ;349
000080  4925              LDR      r1,|L4.280|
000082  6088              STR      r0,[r1,#8]            ;349  ; G_APDU
                  |L4.132|
000084  0a20              LSRS     r0,r4,#8              ;350
000086  4924              LDR      r1,|L4.280|
000088  7308              STRB     r0,[r1,#0xc]          ;350
00008a  734c              STRB     r4,[r1,#0xd]          ;351
00008c  e03d              B        |L4.266|
00008e  f7fffffe          BL       CMD_BOOT_CRC_DATA
000092  4604              MOV      r4,r0                 ;363
000094  f5b44f10          CMP      r4,#0x9000            ;364
000098  d002              BEQ      |L4.160|
00009a  2000              MOVS     r0,#0                 ;365
00009c  491e              LDR      r1,|L4.280|
00009e  6088              STR      r0,[r1,#8]            ;365  ; G_APDU
                  |L4.160|
0000a0  0a20              LSRS     r0,r4,#8              ;366
0000a2  491d              LDR      r1,|L4.280|
0000a4  7308              STRB     r0,[r1,#0xc]          ;366
0000a6  734c              STRB     r4,[r1,#0xd]          ;367
0000a8  e02f              B        |L4.266|
0000aa  f7fffffe          BL       CMD_BOOT_GetID_SPIFlash
0000ae  4604              MOV      r4,r0                 ;370
0000b0  f5b44f10          CMP      r4,#0x9000            ;371
0000b4  d002              BEQ      |L4.188|
0000b6  2000              MOVS     r0,#0                 ;372
0000b8  4917              LDR      r1,|L4.280|
0000ba  6088              STR      r0,[r1,#8]            ;372  ; G_APDU
                  |L4.188|
0000bc  0a20              LSRS     r0,r4,#8              ;373
0000be  4916              LDR      r1,|L4.280|
0000c0  7308              STRB     r0,[r1,#0xc]          ;373
0000c2  734c              STRB     r4,[r1,#0xd]          ;374
0000c4  e021              B        |L4.266|
0000c6  f7fffffe          BL       CMD_BOOT_Read_SPIFlash
0000ca  4604              MOV      r4,r0                 ;377
0000cc  f5b44f10          CMP      r4,#0x9000            ;378
0000d0  d002              BEQ      |L4.216|
0000d2  2000              MOVS     r0,#0                 ;379
0000d4  4910              LDR      r1,|L4.280|
0000d6  6088              STR      r0,[r1,#8]            ;379  ; G_APDU
                  |L4.216|
0000d8  0a20              LSRS     r0,r4,#8              ;380
0000da  490f              LDR      r1,|L4.280|
0000dc  7308              STRB     r0,[r1,#0xc]          ;380
0000de  734c              STRB     r4,[r1,#0xd]          ;381
0000e0  e013              B        |L4.266|
0000e2  f7fffffe          BL       CMD_BOOT_Write_SPIFlash
0000e6  4604              MOV      r4,r0                 ;384
0000e8  f5b44f10          CMP      r4,#0x9000            ;385
0000ec  d002              BEQ      |L4.244|
0000ee  2000              MOVS     r0,#0                 ;386
0000f0  4909              LDR      r1,|L4.280|
0000f2  6088              STR      r0,[r1,#8]            ;386  ; G_APDU
                  |L4.244|
0000f4  0a20              LSRS     r0,r4,#8              ;387
0000f6  4908              LDR      r1,|L4.280|
0000f8  7308              STRB     r0,[r1,#0xc]          ;387
0000fa  734c              STRB     r4,[r1,#0xd]          ;388
0000fc  e005              B        |L4.266|
                  |L4.254|
0000fe  2000              MOVS     r0,#0                 ;391
000100  4905              LDR      r1,|L4.280|
000102  6088              STR      r0,[r1,#8]            ;391  ; G_APDU
000104  f44f44da          MOV      r4,#0x6d00            ;392
000108  bf00              NOP                            ;393
                  |L4.266|
00010a  bf00              NOP                            ;338
00010c  0a20              LSRS     r0,r4,#8              ;396
00010e  4902              LDR      r1,|L4.280|
000110  7308              STRB     r0,[r1,#0xc]          ;396
000112  734c              STRB     r4,[r1,#0xd]          ;397
000114  bf00              NOP      
000116  e77f              B        |L4.24|
;;;400    
                          ENDP

                  |L4.280|
                          DCD      G_APDU
                  |L4.284|
00011c  312e352e          DCB      "1.5.7.14",0
000120  372e3134
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.CMD_BOOT_CRC_DATA||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_CRC_DATA PROC
;;;190    
;;;191    unsigned int CMD_BOOT_CRC_DATA(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;192    {
;;;193    	unsigned int len =0;
000002  2400              MOVS     r4,#0
;;;194    	unsigned int ret =0;
000004  2500              MOVS     r5,#0
;;;195    	unsigned char pccrc[8] = {0};
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
;;;196    	unsigned char flag[2] = {0x00,0xAA};
00000c  a016              ADR      r0,|L5.104|
00000e  6800              LDR      r0,[r0,#0]
000010  9000              STR      r0,[sp,#0]
;;;197    	
;;;198    	len = G_APDU.PP4 << 8;			//lc
000012  4816              LDR      r0,|L5.108|
000014  7940              LDRB     r0,[r0,#5]  ; G_APDU
000016  0204              LSLS     r4,r0,#8
;;;199    	len += G_APDU.PP5;				//lc	
000018  4814              LDR      r0,|L5.108|
00001a  7980              LDRB     r0,[r0,#6]  ; G_APDU
00001c  4404              ADD      r4,r4,r0
;;;200    
;;;201    	if(len != 8)
00001e  2c08              CMP      r4,#8
000020  d003              BEQ      |L5.42|
;;;202    	{
;;;203    		ret = SW_VERIFY_CRC_ERROR;
000022  f44f45e0          MOV      r5,#0x7000
;;;204    		return ret;
000026  4628              MOV      r0,r5
                  |L5.40|
;;;205    	}
;;;206    	
;;;207    	memcpy(pccrc,G_APDU.pInData,len);			   //获取上位机传来的mac
;;;208    	
;;;209    	if(memcmp(pccrc,DATA_MAC,8))
;;;210    	{ 
;;;211    	   	G_APDU.RLE = 0;
;;;212    		//BOOT_NVMEM_Write(BOOT_FLAG_ADDR, flag, BOOT_FLAG_LEN);
;;;213    		ret = SW_VERIFY_CRC_ERROR;	   			
;;;214    	}
;;;215    	else
;;;216    	{ 
;;;217    		BOOT_NVMEM_Write(BOOT_FLAG_ADDR, flag+1, BOOT_FLAG_LEN);
;;;218    
;;;219    		//关闭主电源
;;;220    		//GPIO_ResetBits(GPIOB,GPIO_Pin_15);	
;;;221    		G_APDU.RLE = 0;
;;;222    	   	ret = SW_OPERATION_SUCCESS;	   
;;;223    	} 
;;;224    	return ret;
;;;225    
;;;226    }
000028  bd3e              POP      {r1-r5,pc}
                  |L5.42|
00002a  4810              LDR      r0,|L5.108|
00002c  4622              MOV      r2,r4                 ;207
00002e  6901              LDR      r1,[r0,#0x10]         ;207  ; G_APDU
000030  a801              ADD      r0,sp,#4              ;207
000032  f7fffffe          BL       __aeabi_memcpy
000036  2208              MOVS     r2,#8                 ;209
000038  490d              LDR      r1,|L5.112|
00003a  a801              ADD      r0,sp,#4              ;209
00003c  f7fffffe          BL       memcmp
000040  b128              CBZ      r0,|L5.78|
000042  2000              MOVS     r0,#0                 ;211
000044  4909              LDR      r1,|L5.108|
000046  6088              STR      r0,[r1,#8]            ;211  ; G_APDU
000048  f44f45e0          MOV      r5,#0x7000            ;213
00004c  e00a              B        |L5.100|
                  |L5.78|
00004e  2201              MOVS     r2,#1                 ;217
000050  f10d0101          ADD      r1,sp,#1              ;217
000054  4807              LDR      r0,|L5.116|
000056  f7fffffe          BL       BOOT_NVMEM_Write
00005a  2000              MOVS     r0,#0                 ;221
00005c  4903              LDR      r1,|L5.108|
00005e  6088              STR      r0,[r1,#8]            ;221  ; G_APDU
000060  f44f4510          MOV      r5,#0x9000            ;222
                  |L5.100|
000064  4628              MOV      r0,r5                 ;224
000066  e7df              B        |L5.40|
;;;227    
                          ENDP

                  |L5.104|
000068  00                DCB      0
000069  aa00              DCB      170,0
00006b  00                DCB      0
                  |L5.108|
                          DCD      G_APDU
                  |L5.112|
                          DCD      DATA_MAC
                  |L5.116|
                          DCD      0x08005e10

                          AREA ||i.CMD_BOOT_DNLOAD_DATA_DES3||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_DNLOAD_DATA_DES3 PROC
;;;145    
;;;146    unsigned int CMD_BOOT_DNLOAD_DATA_DES3(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;147    {
;;;148    	unsigned int len = 0;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;149    	unsigned int flashaddr = 0;
000006  2400              MOVS     r4,#0
;;;150    //	unsigned int i=0;
;;;151    	unsigned char* desptr;
;;;152        	unsigned char des3key[16];
;;;153    	unsigned char tmpbuf[256];
;;;154    		
;;;155    	//addr is operated
;;;156    	flashaddr += G_APDU.PP1 << 16;
000008  4821              LDR      r0,|L6.144|
00000a  7880              LDRB     r0,[r0,#2]  ; G_APDU
00000c  eb044400          ADD      r4,r4,r0,LSL #16
;;;157    	flashaddr += G_APDU.PP2 << 8;
000010  481f              LDR      r0,|L6.144|
000012  78c0              LDRB     r0,[r0,#3]  ; G_APDU
000014  eb042400          ADD      r4,r4,r0,LSL #8
;;;158    	flashaddr += G_APDU.PP3;
000018  481d              LDR      r0,|L6.144|
00001a  7900              LDRB     r0,[r0,#4]  ; G_APDU
00001c  4404              ADD      r4,r4,r0
;;;159    	
;;;160    	//data length
;;;161    	len =  G_APDU.PP4 << 8;
00001e  481c              LDR      r0,|L6.144|
000020  7940              LDRB     r0,[r0,#5]  ; G_APDU
000022  0200              LSLS     r0,r0,#8
000024  9002              STR      r0,[sp,#8]
;;;162    	len +=  G_APDU.PP5;	
000026  481a              LDR      r0,|L6.144|
000028  7980              LDRB     r0,[r0,#6]  ; G_APDU
00002a  9902              LDR      r1,[sp,#8]
00002c  4408              ADD      r0,r0,r1
00002e  9002              STR      r0,[sp,#8]
;;;163    
;;;164    	desptr = G_APDU.pInData;
000030  4817              LDR      r0,|L6.144|
000032  6905              LDR      r5,[r0,#0x10]  ; G_APDU
;;;165    	
;;;166    	
;;;167    	if(flashaddr == 0)
000034  b91c              CBNZ     r4,|L6.62|
;;;168    	{
;;;169    		memset(DATA_MAC, 0, 8);
000036  4817              LDR      r0,|L6.148|
000038  2100              MOVS     r1,#0
00003a  6001              STR      r1,[r0,#0]  ; DATA_MAC
00003c  6041              STR      r1,[r0,#4]  ; DATA_MAC
                  |L6.62|
;;;170    	}
;;;171    
;;;172    	//BOOT_NVMEM_Read(BOOT_KEY_ADDR, des3key, BOOT_KEY_LEN);
;;;173    
;;;174    	// 3des-112 ecb 解密
;;;175    	DES3_App((unsigned char *)BOOT_KEY_ADDR, 1, NULL, desptr, &len, desptr);
00003e  a802              ADD      r0,sp,#8
000040  462b              MOV      r3,r5
000042  2200              MOVS     r2,#0
000044  2101              MOVS     r1,#1
000046  e9cd0500          STRD     r0,r5,[sp,#0]
00004a  4813              LDR      r0,|L6.152|
00004c  f7fffffe          BL       DES3_App
;;;176    
;;;177    	//计算mac
;;;178    
;;;179    	DES3_App((unsigned char *)BOOT_KEY_ADDR, 0, DATA_MAC, desptr, &len, MAL_Buffer);
000050  4812              LDR      r0,|L6.156|
000052  a902              ADD      r1,sp,#8
000054  462b              MOV      r3,r5
000056  4a0f              LDR      r2,|L6.148|
000058  e9cd1000          STRD     r1,r0,[sp,#0]
00005c  2100              MOVS     r1,#0
00005e  480e              LDR      r0,|L6.152|
000060  f7fffffe          BL       DES3_App
;;;180    
;;;181    	memcpy(DATA_MAC, MAL_Buffer+len -8, 8);
000064  480d              LDR      r0,|L6.156|
000066  9902              LDR      r1,[sp,#8]
000068  4408              ADD      r0,r0,r1
00006a  490a              LDR      r1,|L6.148|
00006c  f8502d08          LDR      r2,[r0,#-8]!
000070  600a              STR      r2,[r1,#0]  ; DATA_MAC
000072  6840              LDR      r0,[r0,#4]
000074  6048              STR      r0,[r1,#4]  ; DATA_MAC
;;;182    
;;;183    	flashaddr = flashaddr + APP_BASE_ADDR;
000076  480a              LDR      r0,|L6.160|
000078  4404              ADD      r4,r4,r0
;;;184    	
;;;185    	BOOT_NVMEM_Write(flashaddr, desptr, len);
00007a  4629              MOV      r1,r5
00007c  4620              MOV      r0,r4
00007e  9a02              LDR      r2,[sp,#8]
000080  f7fffffe          BL       BOOT_NVMEM_Write
;;;186    
;;;187    	G_APDU.RLE = 0;
000084  2000              MOVS     r0,#0
000086  4902              LDR      r1,|L6.144|
000088  6088              STR      r0,[r1,#8]  ; G_APDU
;;;188    	return SW_OPERATION_SUCCESS;
00008a  f44f4010          MOV      r0,#0x9000
;;;189    }
00008e  bd3e              POP      {r1-r5,pc}
;;;190    
                          ENDP

                  |L6.144|
                          DCD      G_APDU
                  |L6.148|
                          DCD      DATA_MAC
                  |L6.152|
                          DCD      0x08005e00
                  |L6.156|
                          DCD      MAL_Buffer
                  |L6.160|
                          DCD      0x08006000

                          AREA ||i.CMD_BOOT_GetID_SPIFlash||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_GetID_SPIFlash PROC
;;;265    
;;;266    unsigned int CMD_BOOT_GetID_SPIFlash(void)
000000  b510              PUSH     {r4,lr}
;;;267    {
;;;268    	unsigned int Flash_ID = 0;
000002  2400              MOVS     r4,#0
;;;269    
;;;270    	//addr is operated
;;;271    	Flash_ID = SPI_FLASH_ReadID();
000004  f7fffffe          BL       SPI_FLASH_ReadID
000008  4604              MOV      r4,r0
;;;272    
;;;273    	if(!Flash_ID)
00000a  b914              CBNZ     r4,|L7.18|
;;;274    	{
;;;275    		Flash_ID = SPI_FLASH_ReadID();
00000c  f7fffffe          BL       SPI_FLASH_ReadID
000010  4604              MOV      r4,r0
                  |L7.18|
;;;276    	}
;;;277    
;;;278    	G_APDU.pOutData[0] = Flash_ID >> 24;
000012  0e20              LSRS     r0,r4,#24
000014  4909              LDR      r1,|L7.60|
000016  6949              LDR      r1,[r1,#0x14]  ; G_APDU
000018  7008              STRB     r0,[r1,#0]
;;;279    	G_APDU.pOutData[1] = Flash_ID >> 16;
00001a  0c20              LSRS     r0,r4,#16
00001c  4907              LDR      r1,|L7.60|
00001e  6949              LDR      r1,[r1,#0x14]  ; G_APDU
000020  7048              STRB     r0,[r1,#1]
;;;280    	G_APDU.pOutData[2] = Flash_ID >> 8;
000022  0a20              LSRS     r0,r4,#8
000024  4905              LDR      r1,|L7.60|
000026  6949              LDR      r1,[r1,#0x14]  ; G_APDU
000028  7088              STRB     r0,[r1,#2]
;;;281    	G_APDU.pOutData[3] = Flash_ID ;
00002a  4904              LDR      r1,|L7.60|
00002c  6949              LDR      r1,[r1,#0x14]  ; G_APDU
00002e  70cc              STRB     r4,[r1,#3]
;;;282    	
;;;283    	G_APDU.RLE = 4;
000030  2004              MOVS     r0,#4
000032  4902              LDR      r1,|L7.60|
000034  6088              STR      r0,[r1,#8]  ; G_APDU
;;;284    	return SW_OPERATION_SUCCESS;
000036  f44f4010          MOV      r0,#0x9000
;;;285    }
00003a  bd10              POP      {r4,pc}
;;;286    
                          ENDP

                  |L7.60|
                          DCD      G_APDU

                          AREA ||i.CMD_BOOT_Read_SPIFlash||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_Read_SPIFlash PROC
;;;246    
;;;247    unsigned int CMD_BOOT_Read_SPIFlash(void)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
;;;249    	unsigned int len = 0;
000002  2500              MOVS     r5,#0
;;;250    	unsigned int flashaddr = 0;
000004  2400              MOVS     r4,#0
;;;251    	//addr is operated
;;;252    	flashaddr += G_APDU.PP1 << 16;
000006  480e              LDR      r0,|L8.64|
000008  7880              LDRB     r0,[r0,#2]  ; G_APDU
00000a  eb044400          ADD      r4,r4,r0,LSL #16
;;;253    	flashaddr += G_APDU.PP2  << 8;
00000e  480c              LDR      r0,|L8.64|
000010  78c0              LDRB     r0,[r0,#3]  ; G_APDU
000012  eb042400          ADD      r4,r4,r0,LSL #8
;;;254    	flashaddr += G_APDU.PP3 ;
000016  480a              LDR      r0,|L8.64|
000018  7900              LDRB     r0,[r0,#4]  ; G_APDU
00001a  4404              ADD      r4,r4,r0
;;;255    
;;;256    	flashaddr += SPI_FONT_BASE_ADDR;
00001c  bf00              NOP      
;;;257    			
;;;258    	//data length
;;;259    	len =   G_APDU.PP4 << 8;
00001e  4808              LDR      r0,|L8.64|
000020  7940              LDRB     r0,[r0,#5]  ; G_APDU
000022  0205              LSLS     r5,r0,#8
;;;260    	len += G_APDU.PP5 ;	
000024  4806              LDR      r0,|L8.64|
000026  7980              LDRB     r0,[r0,#6]  ; G_APDU
000028  4405              ADD      r5,r5,r0
;;;261    	MSD_ReadBuffer(G_APDU.pOutData, flashaddr, len);
00002a  4905              LDR      r1,|L8.64|
00002c  462a              MOV      r2,r5
00002e  6948              LDR      r0,[r1,#0x14]  ; G_APDU
000030  4621              MOV      r1,r4
000032  f7fffffe          BL       MSD_ReadBuffer
;;;262    	G_APDU.RLE = len;
000036  4802              LDR      r0,|L8.64|
000038  6085              STR      r5,[r0,#8]  ; G_APDU
;;;263    	return SW_OPERATION_SUCCESS;
00003a  f44f4010          MOV      r0,#0x9000
;;;264    }
00003e  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  |L8.64|
                          DCD      G_APDU

                          AREA ||i.CMD_BOOT_Write_Key||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_Write_Key PROC
;;;116    
;;;117    unsigned int CMD_BOOT_Write_Key(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119    	unsigned int ret = 0;
000002  2400              MOVS     r4,#0
;;;120    	
;;;121    	switch(G_APDU.PP1)
000004  481a              LDR      r0,|L9.112|
000006  7880              LDRB     r0,[r0,#2]  ; G_APDU
000008  b120              CBZ      r0,|L9.20|
00000a  2801              CMP      r0,#1
00000c  d00e              BEQ      |L9.44|
00000e  2802              CMP      r0,#2
000010  d125              BNE      |L9.94|
000012  e017              B        |L9.68|
                  |L9.20|
;;;122    	{
;;;123    	case 00:								 
;;;124    		BOOT_NVMEM_Read(BOOT_KEY_ADDR, G_APDU.pOutData, BOOT_KEY_LEN);
000014  4816              LDR      r0,|L9.112|
000016  2210              MOVS     r2,#0x10
000018  6941              LDR      r1,[r0,#0x14]  ; G_APDU
00001a  4816              LDR      r0,|L9.116|
00001c  f7fffffe          BL       BOOT_NVMEM_Read
;;;125    		G_APDU.RLE = BOOT_KEY_LEN;
000020  2010              MOVS     r0,#0x10
000022  4913              LDR      r1,|L9.112|
000024  6088              STR      r0,[r1,#8]  ; G_APDU
;;;126    		ret = SW_OPERATION_SUCCESS;
000026  f44f4410          MOV      r4,#0x9000
;;;127    	break;
00002a  e01e              B        |L9.106|
                  |L9.44|
;;;128       	case 01:
;;;129    		BOOT_NVMEM_Write(BOOT_KEY_ADDR, G_APDU.pInData, BOOT_KEY_LEN);
00002c  4810              LDR      r0,|L9.112|
00002e  2210              MOVS     r2,#0x10
000030  6901              LDR      r1,[r0,#0x10]  ; G_APDU
000032  4810              LDR      r0,|L9.116|
000034  f7fffffe          BL       BOOT_NVMEM_Write
;;;130    		G_APDU.RLE = 0;
000038  2000              MOVS     r0,#0
00003a  490d              LDR      r1,|L9.112|
00003c  6088              STR      r0,[r1,#8]  ; G_APDU
;;;131    		ret = SW_OPERATION_SUCCESS;
00003e  f44f4410          MOV      r4,#0x9000
;;;132    	break;
000042  e012              B        |L9.106|
                  |L9.68|
;;;133    	case 02:
;;;134    		BOOT_NVMEM_Write(DEVICE_INFO_DEV_VER_ADDR, G_APDU.pInData, DEVICE_INFO_DEV_VER_ADDR_LEN);
000044  480a              LDR      r0,|L9.112|
000046  220a              MOVS     r2,#0xa
000048  6901              LDR      r1,[r0,#0x10]  ; G_APDU
00004a  480a              LDR      r0,|L9.116|
00004c  3080              ADDS     r0,r0,#0x80
00004e  f7fffffe          BL       BOOT_NVMEM_Write
;;;135    		G_APDU.RLE = 0;
000052  2000              MOVS     r0,#0
000054  4906              LDR      r1,|L9.112|
000056  6088              STR      r0,[r1,#8]  ; G_APDU
;;;136    		ret = SW_OPERATION_SUCCESS;
000058  f44f4410          MOV      r4,#0x9000
;;;137    	break;
00005c  e005              B        |L9.106|
                  |L9.94|
;;;138    	default:
;;;139    		ret = SW_P1P2_ERROR;//------返回P1P2参数错误
00005e  f6462486          MOV      r4,#0x6a86
;;;140    		G_APDU.RLE = 0;
000062  2000              MOVS     r0,#0
000064  4902              LDR      r1,|L9.112|
000066  6088              STR      r0,[r1,#8]  ; G_APDU
000068  bf00              NOP                            ;121
                  |L9.106|
00006a  bf00              NOP                            ;127
;;;141    	}
;;;142    			 
;;;143    	return ret;
00006c  4620              MOV      r0,r4
;;;144    }
00006e  bd10              POP      {r4,pc}
;;;145    
                          ENDP

                  |L9.112|
                          DCD      G_APDU
                  |L9.116|
                          DCD      0x08005e00

                          AREA ||i.CMD_BOOT_Write_SPIFlash||, CODE, READONLY, ALIGN=2

                  CMD_BOOT_Write_SPIFlash PROC
;;;227    
;;;228    unsigned int CMD_BOOT_Write_SPIFlash(void)
000000  b570              PUSH     {r4-r6,lr}
;;;229    {
;;;230    	unsigned int len = 0;
000002  2500              MOVS     r5,#0
;;;231    	unsigned int flashaddr = 0;
000004  2400              MOVS     r4,#0
;;;232    	//addr is operated
;;;233    	flashaddr += G_APDU.PP1 << 16;
000006  480f              LDR      r0,|L10.68|
000008  7880              LDRB     r0,[r0,#2]  ; G_APDU
00000a  eb044400          ADD      r4,r4,r0,LSL #16
;;;234    	flashaddr += G_APDU.PP2  << 8;
00000e  480d              LDR      r0,|L10.68|
000010  78c0              LDRB     r0,[r0,#3]  ; G_APDU
000012  eb042400          ADD      r4,r4,r0,LSL #8
;;;235    	flashaddr += G_APDU.PP3 ;
000016  480b              LDR      r0,|L10.68|
000018  7900              LDRB     r0,[r0,#4]  ; G_APDU
00001a  4404              ADD      r4,r4,r0
;;;236    
;;;237    	flashaddr += SPI_FONT_BASE_ADDR;
00001c  bf00              NOP      
;;;238    			
;;;239    	//data length
;;;240    	len =   G_APDU.PP4 << 8;
00001e  4809              LDR      r0,|L10.68|
000020  7940              LDRB     r0,[r0,#5]  ; G_APDU
000022  0205              LSLS     r5,r0,#8
;;;241    	len += G_APDU.PP5 ;	
000024  4807              LDR      r0,|L10.68|
000026  7980              LDRB     r0,[r0,#6]  ; G_APDU
000028  4405              ADD      r5,r5,r0
;;;242    	MSD_WriteBlock(G_APDU.pInData, flashaddr, len);
00002a  b2aa              UXTH     r2,r5
00002c  4905              LDR      r1,|L10.68|
00002e  6908              LDR      r0,[r1,#0x10]  ; G_APDU
000030  4621              MOV      r1,r4
000032  f7fffffe          BL       MSD_WriteBlock
;;;243    	G_APDU.RLE = 0;
000036  2000              MOVS     r0,#0
000038  4902              LDR      r1,|L10.68|
00003a  6088              STR      r0,[r1,#8]  ; G_APDU
;;;244    	return SW_OPERATION_SUCCESS;
00003c  f44f4010          MOV      r0,#0x9000
;;;245    }
000040  bd70              POP      {r4-r6,pc}
;;;246    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      G_APDU

                          AREA ||i.Format_APDU||, CODE, READONLY, ALIGN=2

                  Format_APDU PROC
;;;107    
;;;108    void Format_APDU()
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110    	memset(&G_APDU, 0, sizeof(G_APDU));
000002  2118              MOVS     r1,#0x18
000004  4803              LDR      r0,|L11.20|
000006  f7fffffe          BL       __aeabi_memclr4
;;;111    	
;;;112    	G_APDU.pInData = APDU_Buf;
00000a  4803              LDR      r0,|L11.24|
00000c  4901              LDR      r1,|L11.20|
00000e  6108              STR      r0,[r1,#0x10]  ; G_APDU
;;;113    	G_APDU.pOutData = APDU_Buf;
000010  6148              STR      r0,[r1,#0x14]  ; G_APDU
;;;114    
;;;115    }
000012  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  |L11.20|
                          DCD      G_APDU
                  |L11.24|
                          DCD      APDU_Buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  G_APDU
                          %        24
                  APDU_Buf
                          %        2048

                          AREA ||.data||, DATA, ALIGN=0

                  DATA_MAC
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\app_boot.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_app_boot_c_d97174e3____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_app_boot_c_d97174e3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_app_boot_c_d97174e3____REVSH|
#line 144
|__asm___10_app_boot_c_d97174e3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
